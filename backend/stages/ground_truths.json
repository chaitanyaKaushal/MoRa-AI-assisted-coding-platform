{
  "metadata": {
    "count": 292,
    "format_version": "1.0"
  },
  "ground_truths": [
    {
      "task_id": "number-of-ways-to-reorder-array-to-get-same-bst",
      "problem_description": "Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.",
      "examples": [
        "Input: nums = [2,1,3]\nOutput: 1",
        "Input: nums = [3,4,5,1,2]\nOutput: 5",
        "Input: nums = [1,2,3]\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 1000",
        "1 <= nums[i] <= nums.length",
        "All integers in nums are distinct."
      ]
    },
    {
      "task_id": "insert-into-a-binary-search-tree",
      "problem_description": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.",
      "examples": [
        "Input: root = [4,2,7,1,3], val = 5\nOutput: [4,2,7,1,3,5]",
        "Input: root = [40,20,60,10,30,50,70], val = 25\nOutput: [40,20,60,10,30,50,70,null,null,25]",
        "Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\nOutput: [4,2,7,1,3,5]"
      ],
      "constraints": [
        "The number of nodes in the tree will be in the range [0, 10^4].",
        "-108 <= Node.val <= 108",
        "All the values Node.val are unique.",
        "-108 <= val <= 108",
        "It's guaranteed that val does not exist in the original BST."
      ]
    },
    {
      "task_id": "two-sum-iv-input-is-a-bst",
      "problem_description": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.",
      "examples": [
        "Input: root = [5,3,6,2,4,null,7], k = 9\nOutput: true",
        "Input: root = [5,3,6,2,4,null,7], k = 28\nOutput: false"
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 104].",
        "-104 <= Node.val <= 104",
        "root is guaranteed to be a valid binary search tree.",
        "-105 <= k <= 105"
      ]
    },
    {
      "task_id": "all-elements-in-two-binary-search-trees",
      "problem_description": "Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.",
      "examples": [
        "Input: root1 = [2,1,4], root2 = [1,0,3]\nOutput: [0,1,1,2,3,4]",
        "Input: root1 = [1,null,8], root2 = [8,1]\nOutput: [1,1,8,8]"
      ],
      "constraints": [
        "The number of nodes in each tree is in the range [0, 5000].",
        "-105 <= Node.val <= 105"
      ]
    },
    {
      "task_id": "depth-of-bst-given-insertion-order",
      "problem_description": "You are given a 0-indexed integer array order of length n, a permutation of integers from 1 to n representing the order of insertion into a binary search tree. A binary search tree is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. The binary search tree is constructed as follows: order[0] will be the root of the binary search tree. All subsequent elements are inserted as the child of any existing node such that the binary search tree properties hold. Return the depth of the binary search tree. A binary tree's depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "examples": [
        "Input: order = [2,1,4,3]\nOutput: 3",
        "Input: order = [2,1,3,4]\nOutput: 3",
        "Input: order = [1,2,3,4]\nOutput: 4"
      ],
      "constraints": [
        "n == order.length",
        "1 <= n <= 105",
        "order is a permutation of integers between 1 and n."
      ]
    },
    {
      "task_id": "minimum-number-of-coins-for-fruits",
      "problem_description": "You are given an 0-indexed integer array prices where prices[i] denotes the number of coins needed to purchase the (i + 1)th fruit. The fruit market has the following reward for each fruit: If you purchase the (i + 1)th fruit at prices[i] coins, you can get any number of the next i fruits for free. Note that even if you can take fruit j for free, you can still purchase it for prices[j - 1] coins to receive its reward. Return the minimum number of coins needed to acquire all the fruits.",
      "examples": [
        "Input: prices = [3,1,2]\nOutput: 4",
        "Input: prices = [1,10,1,1]\nOutput: 2",
        "Input: prices = [26,18,6,12,49,7,45,45]\nOutput: 39"
      ],
      "constraints": [
        "1 <= prices.length <= 1000",
        "1 <= prices[i] <= 105"
      ]
    },
    {
      "task_id": "sliding-window-maximum",
      "problem_description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
      "examples": [
        "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]",
        "Input: nums = [1], k = 1\nOutput: [1]"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-104 <= nums[i] <= 104",
        "1 <= k <= nums.length"
      ]
    },
    {
      "task_id": "minimum-number-of-coins-for-fruits-ii",
      "problem_description": "You are given a 1-indexed array prices, where prices[i] denotes the number of coins needed to purchase the ith fruit. The fruit market has the following offer: If you purchase the ith fruit at prices[i] coins, you can get the next i fruits for free. Note that even if you can take fruit j for free, you can still purchase it for prices[j] coins to receive a new offer. Return the minimum number of coins needed to acquire all the fruits.",
      "examples": [
        "Input: prices = [3,1,2]\nOutput: 4",
        "Input: prices = [1,10,1,1]\nOutput: 2"
      ],
      "constraints": [
        "1 <= prices.length <= 105",
        "1 <= prices[i] <= 105"
      ]
    },
    {
      "task_id": "count-subarrays-with-fixed-bounds",
      "problem_description": "You are given an integer array nums and two integers minK and maxK. A fixed-bound subarray of nums is a subarray that satisfies the following conditions: The minimum value in the subarray is equal to minK. The maximum value in the subarray is equal to maxK. Return the number of fixed-bound subarrays. A subarray is a contiguous part of an array.",
      "examples": [
        "Input: nums = [1,3,5,2,7,5], minK = 1, maxK = 5\nOutput: 2",
        "Input: nums = [1,1,1,1], minK = 1, maxK = 1\nOutput: 10"
      ],
      "constraints": [
        "2 <= nums.length <= 105",
        "1 <= nums[i], minK, maxK <= 106"
      ]
    },
    {
      "task_id": "longest-increasing-subsequence-ii",
      "problem_description": "You are given an integer array nums and an integer k. Find the longest subsequence of nums that meets the following requirements: The subsequence is strictly increasing and The difference between adjacent elements in the subsequence is at most k. Return the length of the longest subsequence that meets the requirements. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
      "examples": [
        "Input: nums = [4,2,1,4,3,4,5,8,15], k = 3\nOutput: 5",
        "Input: nums = [7,4,5,1,8,12,4,7], k = 5\nOutput: 4",
        "Input: nums = [1,5], k = 1\nOutput: 1"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i], k <= 105"
      ]
    },
    {
      "task_id": "is-array-a-preorder-of-some-binary-tree",
      "problem_description": "Given a 0-indexed integer 2D array nodes, your task is to determine if the given array represents the preorder traversal of some binary tree. For each index i, nodes[i] = [id, parentId], where id is the id of the node at the index i and parentId is the id of its parent in the tree (if the node has no parent, then parentId == -1). Return true if the given array represents the preorder traversal of some tree, and false otherwise. Note: the preorder traversal of a tree is a recursive way to traverse a tree in which we first visit the current node, then we do the preorder traversal for the left child, and finally, we do it for the right child.",
      "examples": [
        "Input: nodes = [[0,-1],[1,0],[2,0],[3,2],[4,2]]\nOutput: true",
        "Input: nodes = [[0,-1],[1,0],[2,0],[3,1],[4,1]]\nOutput: false"
      ],
      "constraints": [
        "1 <= nodes.length <= 105",
        "nodes[i].length == 2",
        "0 <= nodes[i][0] <= 105",
        "-1 <= nodes[i][1] <= 105",
        "The input is generated such that nodes make a binary tree."
      ]
    },
    {
      "task_id": "longest-increasing-path-in-a-matrix",
      "problem_description": "Given an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
      "examples": [
        "Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].",
        "Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.",
        "Input: matrix = [[1]]\nOutput: 1"
      ],
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 200",
        "0 <= matrix[i][j] <= 231 - 1"
      ]
    },
    {
      "task_id": "lowest-common-ancestor-of-deepest-leaves",
      "problem_description": "Given the root of a binary tree, return the lowest common ancestor of its deepest leaves. The node of a binary tree is a leaf if and only if it has no children. The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1. The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.",
      "examples": [
        "Input: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]",
        "Input: root = [1]\nOutput: [1]",
        "Input: root = [0,1,3,null,2]\nOutput: [2]"
      ],
      "constraints": [
        "The number of nodes in the tree will be in the range [1, 1000].",
        "0 <= Node.val <= 1000",
        "The values of the nodes in the tree are unique."
      ]
    },
    {
      "task_id": "is-graph-bipartite",
      "problem_description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite.",
      "examples": [
        "Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.",
        "Input: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}."
      ],
      "constraints": [
        "graph.length == n",
        "1 <= n <= 100",
        "0 <= graph[u].length < n",
        "0 <= graph[u][i] <= n - 1",
        "graph[u] does not contain u.",
        "All the values of graph[u] are unique.",
        "If graph[u] contains v, then graph[v] contains u."
      ]
    },
    {
      "task_id": "sum-of-remoteness-of-all-cells",
      "problem_description": "You are given a 0-indexed matrix grid of order n * n. Each cell in this matrix has a value grid[i][j], which is either a positive integer or -1 representing a blocked cell. You can move from a non-blocked cell to any non-blocked cell that shares an edge. For any cell (i, j), we represent its remoteness as R[i][j] which is defined as the following: If the cell (i, j) is a non-blocked cell, R[i][j] is the sum of the values grid[x][y] such that there is no path from the non-blocked cell (x, y) to the cell (i, j). For blocked cells, R[i][j] == 0. Return the sum of R[i][j] over all cells.",
      "examples": [
        "Input: grid = [[-1,1,-1],[5,-1,4],[-1,3,-1]]\nOutput: 39",
        "Input: grid = [[-1,3,4],[-1,-1,-1],[3,-1,-1]]\nOutput: 13",
        "Input: grid = [[1]]\nOutput: 0"
      ],
      "constraints": [
        "1 <= n <= 300",
        "1 <= grid[i][j] <= 106 or grid[i][j] == -1"
      ]
    },
    {
      "task_id": "sort-an-array",
      "problem_description": "Given an array of integers nums, sort the array in ascending order and return it. You must solve the problem without using any built-in functions.",
      "examples": [
        "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]",
        "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]"
      ],
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "-5 * 104 <= nums[i] <= 5 * 104"
      ]
    },
    {
      "task_id": "maximum-gap",
      "problem_description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.",
      "examples": [
        "Input: nums = [3,6,9,1]\nOutput: 3",
        "Input: nums = [10]\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 109"
      ]
    },
    {
      "task_id": "query-kth-smallest-trimmed-number",
      "problem_description": "You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits. You are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to: Trim each number in nums to its rightmost trimi digits. Determine the index of the kith smallest trimmed number in nums. If two trimmed numbers are equal, the number with the lower index is considered to be smaller. Reset each number in nums to its original length. Return an array answer of the same length as queries, where answer[i] is the answer to the ith query. To trim to the rightmost x digits means to keep removing the leftmost digit, until only x digits remain. Strings in nums may contain leading zeros.",
      "examples": [
        "Input: nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\nOutput: [2,2,1,0]",
        "Input: nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\nOutput: [3,0]"
      ],
      "constraints": [
        "1 <= nums.length <= 100",
        "1 <= nums[i].length <= 100",
        "nums[i] consists of only digits.",
        "All nums[i].length are equal.",
        "1 <= queries.length <= 100",
        "queries[i].length == 2",
        "1 <= ki <= nums.length",
        "1 <= trimi <= nums[i].length"
      ]
    },
    {
      "task_id": "fair-candy-swap",
      "problem_description": "Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. It is guaranteed that at least one answer exists.",
      "examples": [
        "Input: aliceSizes = [1,1], bobSizes = [2,2]\nOutput: [1,2]",
        "Input: aliceSizes = [1,2], bobSizes = [2,3]\nOutput: [1,2]",
        "Input: aliceSizes = [2], bobSizes = [1,3]\nOutput: [2,3]"
      ],
      "constraints": [
        "1 <= aliceSizes.length, bobSizes.length <= 104",
        "1 <= aliceSizes[i], bobSizes[j] <= 105",
        "Alice and Bob have a different total number of candies.",
        "There will be at least one valid answer for the given input."
      ]
    },
    {
      "task_id": "maximum-count-of-positive-integer-and-negative-integer",
      "problem_description": "Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers. Note that 0 is neither positive nor negative.",
      "examples": [
        "Input: nums = [-2,-1,-1,1,2,3]\nOutput: 3",
        "Input: nums = [-3,-2,-1,0,0,1,2]\nOutput: 3",
        "Input: nums = [5,20,66,1314]\nOutput: 4"
      ],
      "constraints": [
        "1 <= nums.length <= 2000",
        "-2000 <= nums[i] <= 2000",
        "nums is sorted in a non-decreasing order."
      ]
    },
    {
      "task_id": "smallest-rectangle-enclosing-black-pixels",
      "problem_description": "You are given an m x n binary matrix image where 0 represents a white pixel and 1 represents a black pixel. The black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically. Given two integers x and y that represents the location of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.",
      "examples": [
        "Input: image = [[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"0\"]], x = 0, y = 2\nOutput: 6",
        "Input: image = [[\"1\"]], x = 0, y = 0\nOutput: 1"
      ],
      "constraints": [
        "m == image.length",
        "n == image[i].length",
        "1 <= m, n <= 100",
        "image[i][j] is either '0' or '1'.",
        "0 <= x < m",
        "0 <= y < n",
        "image[x][y] == '1'.",
        "The black pixels in the image only form one component."
      ]
    },
    {
      "task_id": "pour-water-between-buckets-to-make-water-levels-equal",
      "problem_description": "You have n buckets each containing some gallons of water in it, represented by a 0-indexed integer array buckets, where the ith bucket contains buckets[i] gallons of water. You are also given an integer loss. You want to make the amount of water in each bucket equal. You can pour any amount of water from one bucket to another bucket (not necessarily an integer). However, every time you pour k gallons of water, you spill loss percent of k. Return the maximum amount of water in each bucket after making the amount of water equal. Answers within 10-5 of the actual answer will be accepted.",
      "examples": [
        "Input: buckets = [1,2,7], loss = 80\nOutput: 2.00000",
        "Input: buckets = [2,4,6], loss = 50\nOutput: 3.50000",
        "Input: buckets = [3,3,3,3], loss = 40\nOutput: 3.00000"
      ],
      "constraints": [
        "1 <= buckets.length <= 105",
        "0 <= buckets[i] <= 105",
        "0 <= loss <= 99"
      ]
    },
    {
      "task_id": "minimum-garden-perimeter-to-collect-enough-apples",
      "problem_description": "In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it. You will buy an axis-aligned square plot of land that is centered at (0, 0). Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot.",
      "examples": [
        "Input: neededApples = 1\nOutput: 8\nExplanation: A square plot of side length 1 does not contain any apples. However, a square plot of side length 2 has 12 apples inside (as depicted in the image above). The perimeter is 2 * 4 = 8.",
        "Input: neededApples = 13\nOutput: 16",
        "Input: neededApples = 1000000000\nOutput: 5040"
      ],
      "constraints": [
        "1 <= neededApples <= 1015"
      ]
    },
    {
      "task_id": "toss-strange-coins",
      "problem_description": "You have some coins. The i-th coin has a probability prob[i] of facing heads when tossed. Return the probability that the number of coins facing heads equals target if you toss every coin exactly once.",
      "examples": [
        "Input: prob = [0.4], target = 1",
        "Input: prob = [0.5,0.5,0.5,0.5,0.5], target = 0"
      ],
      "constraints": [
        "1 <= prob.length <= 1000",
        "0 <= prob[i] <= 1",
        "0 <= target <= prob.length"
      ]
    },
    {
      "task_id": "airplane-seat-assignment-probability",
      "problem_description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: Take their own seat if it is still available, and Pick other seats randomly when they find their seat occupied. Return the probability that the nth person gets his own seat.",
      "examples": [
        "Input: n = 1\nOutput: 1.00000\nExplanation: The first person can only get the first seat.",
        "Input: n = 2\nOutput: 0.50000\nExplanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat)."
      ],
      "constraints": [
        "1 <= n <= 105"
      ]
    },
    {
      "task_id": "soup-servings",
      "problem_description": "There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations: Serve 100 ml of soup A and 0 ml of soup B, Serve 75 ml of soup A and 25 ml of soup B, Serve 50 ml of soup A and 50 ml of soup B, and Serve 25 ml of soup A and 75 ml of soup B. When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup. Note that we do not have an operation where all 100 ml's of soup B are used first. Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.",
      "examples": [
        "Input: n = 50\nOutput: 0.62500\nExplanation: If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.",
        "Input: n = 100\nOutput: 0.71875"
      ],
      "constraints": [
        "0 <= n <= 10^9"
      ]
    },
    {
      "task_id": "new-21-game",
      "problem_description": "Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets k or more points. Return the probability that Alice has n or fewer points.",
      "examples": [
        "Input: n = 10, k = 1, maxPts = 10\nOutput: 1.00000",
        "Input: n = 6, k = 1, maxPts = 10\nOutput: 0.60000",
        "Input: n = 21, k = 17, maxPts = 10\nOutput: 0.73278"
      ],
      "constraints": [
        "0 <= k <= n <= 104",
        "1 <= maxPts <= 104"
      ]
    },
    {
      "task_id": "make-string-anti-palindrome",
      "problem_description": "We call a string s of even length n an anti-palindrome if for each index 0 <= i < n, s[i] != s[n - i - 1]. Given a string s, your task is to make s an anti-palindrome by doing any number of operations (including zero). In one operation, you can select two characters from s and swap them. Return the resulting string. If multiple strings meet the conditions, return the lexicographically smallest one. If it can't be made into an anti-palindrome, return '-1'.",
      "examples": [
        "Input: s = \"abca\"\nOutput: \"aabc\"",
        "Input: s = \"abba\"\nOutput: \"aabb\"",
        "Input: s = \"cccd\"\nOutput: \"-1\""
      ],
      "constraints": [
        "2 <= s.length <= 105",
        "s.length % 2 == 0",
        "s consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "minimum-number-of-pushes-to-type-word-ii",
      "problem_description": "You are given a string word containing lowercase English letters. Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word. Return the minimum number of pushes needed to type word after remapping the keys.",
      "examples": [
        "Input: word = \"abcde\"\nOutput: 5",
        "Input: word = \"xyzxyzxyzxyz\"\nOutput: 12",
        "Input: word = \"aabbccddeeffgghhiiiiii\"\nOutput: 24"
      ],
      "constraints": [
        "1 <= word.length <= 105",
        "word consists of lowercase English letters."
      ]
    },
    {
      "task_id": "sum-of-mutated-array-closest-to-target",
      "problem_description": "Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target. In case of a tie, return the minimum such integer. Notice that the answer is not necessarily a number from arr.",
      "examples": [
        "Input: arr = [4,9,3], target = 10\nOutput: 3\nExplanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.",
        "Input: arr = [2,3,5], target = 10\nOutput: 5",
        "Input: arr = [60864,25176,27249,21296,20204], target = 56803\nOutput: 11361"
      ],
      "constraints": [
        "1 <= arr.length <= 104",
        "1 <= arr[i], target <= 105"
      ]
    },
    {
      "task_id": "most-popular-video-creator",
      "problem_description": "You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creators[i], has an id of ids[i], and has views[i] views. The popularity of a creator is the sum of the number of views on all of the creator's videos. Find the creator with the highest popularity and the id of their most viewed video. If multiple creators have the highest popularity, find all of them. If multiple videos have the highest view count for a creator, find the lexicographically smallest id. It is possible for different videos to have the same id, meaning that ids do not uniquely identify a video. For example, two videos with the same ID are considered as distinct videos with their own viewcount. Return a 2D array of strings answer where answer[i] = [creatorsi, idi] means that creatorsi has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.",
      "examples": [
        "Input: creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4]\nOutput: [[\"alice\",\"one\"],[\"bob\",\"two\"]]",
        "Input: creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2]\nOutput: [[\"alice\",\"b\"]]"
      ],
      "constraints": [
        "n == creators.length == ids.length == views.length",
        "1 <= n <= 105",
        "1 <= creators[i].length, ids[i].length <= 5",
        "creators[i] and ids[i] consist only of lowercase English letters.",
        "0 <= views[i] <= 105"
      ]
    },
    {
      "task_id": "hand-of-straights",
      "problem_description": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
      "examples": [
        "Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\nOutput: true\nExplanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]",
        "Input: hand = [1,2,3,4,5], groupSize = 4\nOutput: false\nExplanation: Alice's hand can not be rearranged into groups of 4."
      ],
      "constraints": [
        "1 <= hand.length <= 104",
        "0 <= hand[i] <= 109",
        "1 <= groupSize <= hand.length"
      ]
    },
    {
      "task_id": "optimal-account-balancing",
      "problem_description": "You are given an array of transactions transactions where transactions[i] = [fromi, toi, amounti] indicates that the person with ID = fromi gave amounti $ to the person with ID = toi. Return the minimum number of transactions required to settle the debt.",
      "examples": [
        "Input: transactions = [[0,1,10],[2,0,5]]\nOutput: 2",
        "Input: transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]\nOutput: 1"
      ],
      "constraints": [
        "1 <= transactions.length <= 8",
        "transactions[i].length == 3",
        "0 <= fromi, toi < 12",
        "fromi != toi",
        "1 <= amounti <= 100"
      ]
    },
    {
      "task_id": "partition-array-into-two-arrays-to-minimize-sum-difference",
      "problem_description": "You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. To partition nums, put each element of nums into one of the two arrays. Return the minimum possible absolute difference.",
      "examples": [
        "Input: nums = [3,9,7,3]\nOutput: 2",
        "Input: nums = [-36,36]\nOutput: 72",
        "Input: nums = [2,-1,0,4,-2,-9]\nOutput: 0"
      ],
      "constraints": [
        "1 <= n <= 15",
        "nums.length == 2 * n",
        "-107 <= nums[i] <= 107"
      ]
    },
    {
      "task_id": "find-the-minimum-cost-array-permutation",
      "problem_description": "You are given an array nums which is a permutation of [0, 1, 2, ..., n - 1]. The score of any permutation of [0, 1, 2, ..., n - 1] named perm is defined as: score(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]| Return the permutation perm which has the minimum possible score. If multiple permutations exist with this score, return the one that is lexicographically smallest among them.",
      "examples": [
        "Input: nums = [1,0,2]\nOutput: [0,1,2]\nExplanation:\n\nThe lexicographically smallest permutation with minimum cost is [0,1,2]. The cost of this permutation is |0 - 0| + |1 - 2| + |2 - 1| = 2.",
        "Input: nums = [0,2,1]\nOutput: [0,2,1]\nExplanation:\n\nThe lexicographically smallest permutation with minimum cost is [0,2,1]. The cost of this permutation is |0 - 1| + |2 - 2| + |1 - 0| = 2."
      ],
      "constraints": [
        "2 <= n == nums.length <= 14",
        "nums is a permutation of [0, 1, 2, ..., n - 1]."
      ]
    },
    {
      "task_id": "maximum-and-sum-of-array",
      "problem_description": "You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots. You have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number. Return the maximum possible AND sum of nums given numSlots slots.",
      "examples": [
        "Input: nums = [1,2,3,4,5,6], numSlots = 3\nOutput: 9",
        "Input: nums = [1,3,10,4,7,1], numSlots = 9\nOutput: 24"
      ],
      "constraints": [
        "n == nums.length",
        "1 <= numSlots <= 9",
        "1 <= n <= 2 * numSlots",
        "1 <= nums[i] <= 15"
      ]
    },
    {
      "task_id": "partition-to-k-equal-sum-subsets",
      "problem_description": "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.",
      "examples": [
        "Input: nums = [4,3,2,3,5,2,1], k = 4\nOutput: true\nExplanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.",
        "Input: nums = [1,2,3,4], k = 3\nOutput: false"
      ],
      "constraints": [
        "1 <= k <= nums.length <= 16",
        "1 <= nums[i] <= 104",
        "The frequency of each element is in the range [1, 4]."
      ]
    },
    {
      "task_id": "maximum-product-of-the-length-of-two-palindromic-substrings",
      "problem_description": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.",
      "examples": [
        "Input: s = \"ababbb\"\nOutput: 9\nExplanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.",
        "Input: s = \"zaaaxbbby\"\nOutput: 9\nExplanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9."
      ],
      "constraints": [
        "2 <= s.length <= 105",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "distinct-echo-substrings",
      "problem_description": "Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).",
      "examples": [
        "Input: text = \"abcabcabc\"\nOutput: 3\nExplanation: The 3 substrings are \"abcabc\", \"bcabca\" and \"cabcab\".",
        "Input: text = \"leetcodeleetcode\"\nOutput: 2\nExplanation: The 2 substrings are \"ee\" and \"leetcodeleetcode\"."
      ],
      "constraints": [
        "1 <= text.length <= 2000",
        "text has only lowercase English letters."
      ]
    },
    {
      "task_id": "count-prefix-and-suffix-pairs-i",
      "problem_description": "You are given a 0-indexed string array words. Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2: isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise. Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.",
      "examples": [
        "Input: words = [\"a\",\"aba\",\"ababa\",\"aa\"]\nOutput: 4",
        "Input: words = [\"pa\",\"papa\",\"ma\",\"mama\"]\nOutput: 2",
        "Input: words = [\"abab\",\"ab\"]\nOutput: 0"
      ],
      "constraints": [
        "1 <= words.length <= 50",
        "1 <= words[i].length <= 10",
        "words[i] consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "number-of-distinct-substrings-in-a-string",
      "problem_description": "Given a string s, return the number of distinct substrings of s. A substring of a string is obtained by deleting any number of characters (possibly zero) from the front of the string and any number (possibly zero) from the back of the string.",
      "examples": [
        "Input: s = \"aabbaba\"\nOutput: 21\nExplanation: The set of distinct strings is [\"a\",\"b\",\"aa\",\"bb\",\"ab\",\"ba\",\"aab\",\"abb\",\"bab\",\"bba\",\"aba\",\"aabb\",\"abba\",\"bbab\",\"baba\",\"aabba\",\"abbab\",\"bbaba\",\"aabbab\",\"abbaba\",\"aabbaba\"]",
        "Input: s = \"abcdefg\"\nOutput: 28"
      ],
      "constraints": [
        "1 <= s.length <= 500",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "number-of-subarrays-that-match-a-pattern-ii",
      "problem_description": "You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1. A subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]: nums[i + k + 1] > nums[i + k] if pattern[k] == 1. nums[i + k + 1] == nums[i + k] if pattern[k] == 0. nums[i + k + 1] < nums[i + k] if pattern[k] == -1. Return the count of subarrays in nums that match the pattern.",
      "examples": [
        "Input: nums = [1,2,3,4,5,6], pattern = [1,1]\nOutput: 4",
        "Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\nOutput: 2"
      ],
      "constraints": [
        "2 <= n == nums.length <= 106",
        "1 <= nums[i] <= 109",
        "1 <= m == pattern.length < n",
        "-1 <= pattern[i] <= 1"
      ]
    },
    {
      "task_id": "find-edges-in-shortest-paths",
      "problem_description": "You are given an undirected weighted graph of n nodes numbered from 0 to n - 1. The graph consists of m edges represented by a 2D array edges, where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi. Consider all the shortest paths from node 0 to node n - 1 in the graph. You need to find a boolean array answer where answer[i] is true if the edge edges[i] is part of at least one shortest path. Otherwise, answer[i] is false. Note that the graph may not be connected.",
      "examples": [
        "Input: n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\nOutput: [true,true,true,false,true,true,true,false]",
        "Input: n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\nOutput: [true,false,false,true]"
      ],
      "constraints": [
        "2 <= n <= 5 * 104",
        "m == edges.length",
        "1 <= m <= min(5 * 104, n * (n - 1) / 2)",
        "0 <= ai, bi < n",
        "ai != bi",
        "1 <= wi <= 105",
        "There are no repeated edges."
      ]
    },
    {
      "task_id": "pizza-with-3n-slices",
      "problem_description": "There is a pizza with 3n slices of varying size. You and your friends will take slices of pizza as follows: You will pick any pizza slice. Your friend Alice will pick the next slice in the anti-clockwise direction of your pick. Your friend Bob will pick the next slice in the clockwise direction of your pick. Repeat until there are no more slices of pizzas. Given an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.",
      "examples": [
        "Input: slices = [1,2,3,4,5,6]\nOutput: 10\nExplanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.",
        "Input: slices = [8,9,8,6,1,1]\nOutput: 16\nExplanation: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8."
      ],
      "constraints": [
        "3 * n == slices.length",
        "1 <= slices.length <= 500",
        "1 <= slices[i] <= 1000"
      ]
    },
    {
      "task_id": "sliding-window-maximum",
      "problem_description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
      "examples": [
        "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]",
        "Input: nums = [1], k = 1\nOutput: [1]"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-104 <= nums[i] <= 104",
        "1 <= k <= nums.length"
      ]
    },
    {
      "task_id": "furthest-building-you-can-reach",
      "problem_description": "You are given an integer array heights representing the heights of buildings, some bricks, and some ladders. You start your journey from building 0 and move to the next building by possibly using bricks or ladders. While moving from building i to building i+1 (0-indexed), If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks. If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.",
      "examples": [
        "Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\nOutput: 4",
        "Input: heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\nOutput: 7",
        "Input: heights = [14,3,19,3], bricks = 17, ladders = 0\nOutput: 3"
      ],
      "constraints": [
        "1 <= heights.length <= 105",
        "1 <= heights[i] <= 106",
        "0 <= bricks <= 109",
        "0 <= ladders <= heights.length"
      ]
    },
    {
      "task_id": "maximum-number-of-points-from-grid-queries",
      "problem_description": "You are given an m x n integer matrix grid and an array queries of size k. Find an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process: If queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right. Otherwise, you do not get any points, and you end this process. After the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.",
      "examples": [
        "Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]",
        "Input: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]"
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "2 <= m, n <= 1000",
        "4 <= m * n <= 105",
        "k == queries.length",
        "1 <= k <= 104",
        "1 <= grid[i][j], queries[i] <= 106"
      ]
    },
    {
      "task_id": "find-the-most-competitive-subsequence",
      "problem_description": "Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k. An array's subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array. We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b.",
      "examples": [
        "Input: nums = [3,5,2,6], k = 2\nOutput: [2,6]",
        "Input: nums = [2,4,3,3,5,4,9,6], k = 4\nOutput: [2,3,3,4]"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 109",
        "1 <= k <= nums.length"
      ]
    },
    {
      "task_id": "increasing-order-search-tree",
      "problem_description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
      "examples": [
        "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
        "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]"
      ],
      "constraints": [
        "The number of nodes in the given tree will be in the range [1, 100].",
        "0 <= Node.val <= 1000"
      ]
    },
    {
      "task_id": "maximum-score-of-a-good-subarray",
      "problem_description": "You are given an array of integers nums (0-indexed) and an integer k. The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j. Return the maximum possible score of a good subarray.",
      "examples": [
        "Input: nums = [1,4,3,7,4,5], k = 3\nOutput: 15",
        "Input: nums = [5,5,4,5,4,1,1,1], k = 0\nOutput: 20"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 2 * 104",
        "0 <= k < nums.length"
      ]
    },
    {
      "task_id": "number-of-students-unable-to-eat-lunch",
      "problem_description": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step: If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue. Otherwise, they will leave it and go to the queue's end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i\u200b\u200b\u200b\u200b\u200b\u200bth sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j\u200b\u200b\u200b\u200b\u200b\u200bth student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.",
      "examples": [
        "Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\nOutput: 0",
        "Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\nOutput: 3"
      ],
      "constraints": [
        "1 <= students.length, sandwiches.length <= 100",
        "students.length == sandwiches.length",
        "sandwiches[i] is 0 or 1.",
        "students[i] is 0 or 1."
      ]
    },
    {
      "task_id": "score-of-parentheses",
      "problem_description": "Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule: '()' has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.",
      "examples": [
        "Input: s = '()'\nOutput: 1",
        "Input: s = '(())'\nOutput: 2",
        "Input: s = '()()'\nOutput: 2"
      ],
      "constraints": [
        "2 <= s.length <= 50",
        "s consists of only '(' and ')'.",
        "s is a balanced parentheses string."
      ]
    },
    {
      "task_id": "count-nodes-that-are-great-enough",
      "problem_description": "You are given a root to a binary tree and an integer k. A node of this tree is called great enough if the followings hold: Its subtree has at least k nodes. Its value is greater than the value of at least k nodes in its subtree. Return the number of nodes in this tree that are great enough. The node u is in the subtree of the node v, if u == v or v is an ancestor of u.",
      "examples": [
        "Input: root = [7,6,5,4,3,2,1], k = 2\nOutput: 3",
        "Input: root = [1,2,3], k = 1\nOutput: 0",
        "Input: root = [3,2,2], k = 2\nOutput: 1"
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 104].",
        "1 <= Node.val <= 104",
        "1 <= k <= 10"
      ]
    },
    {
      "task_id": "lowest-common-ancestor-of-deepest-leaves",
      "problem_description": "Given the root of a binary tree, return the lowest common ancestor of its deepest leaves. The node of a binary tree is a leaf if and only if it has no children. The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1. The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A.",
      "examples": [
        "Input: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]",
        "Input: root = [1]\nOutput: [1]",
        "Input: root = [0,1,3,null,2]\nOutput: [2]"
      ],
      "constraints": [
        "The number of nodes in the tree will be in the range [1, 1000].",
        "0 <= Node.val <= 1000",
        "The values of the nodes in the tree are unique."
      ]
    },
    {
      "task_id": "cycle-length-queries-in-a-tree",
      "problem_description": "You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where: The left node has the value 2 * val, and the right node has the value 2 * val + 1. You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem: Add an edge between the nodes with values ai and bi. Find the length of the cycle in the graph. Remove the added edge between nodes with values ai and bi. Note that: A cycle is a path that starts and ends at the same node, and each edge in the path is visited only once. The length of a cycle is the number of edges visited in the cycle. There could be multiple edges between two nodes in the tree after adding the edge of the query. Return an array answer of length m where answer[i] is the answer to the ith query.",
      "examples": [
        "Input: n = 3, queries = [[5,3],[4,7],[2,3]]\nOutput: [4,5,3]",
        "Input: n = 2, queries = [[1,2]]\nOutput: [2]"
      ],
      "constraints": [
        "2 <= n <= 30",
        "m == queries.length",
        "1 <= m <= 105",
        "queries[i].length == 2",
        "1 <= ai, bi <= 2n - 1",
        "ai != bi"
      ]
    },
    {
      "task_id": "check-completeness-of-a-binary-tree",
      "problem_description": "Given the root of a binary tree, determine if it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.",
      "examples": [
        "Input: root = [1,2,3,4,5,6]\nOutput: true\nExplanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.",
        "Input: root = [1,2,3,4,5,null,7]\nOutput: false\nExplanation: The node with value 7 isn't as far left as possible."
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 100].",
        "1 <= Node.val <= 1000"
      ]
    },
    {
      "task_id": "path-sum-iv",
      "problem_description": "If the depth of a tree is smaller than 5, then this tree can be represented by an array of three-digit integers. You are given an ascending array nums consisting of three-digit integers representing a binary tree with a depth smaller than 5, where for each integer: The hundreds digit represents the depth d of this node, where 1 <= d <= 4. The tens digit represents the position p of this node within its level, where 1 <= p <= 8, corresponding to its position in a full binary tree. The units digit represents the value v of this node, where 0 <= v <= 9. Return the sum of all paths from the root towards the leaves. It is guaranteed that the given array represents a valid connected binary tree.",
      "examples": [
        "Input: nums = [113,215,221]\nOutput: 12",
        "Input: nums = [113,221]\nOutput: 4"
      ],
      "constraints": [
        "1 <= nums.length <= 15",
        "110 <= nums[i] <= 489",
        "nums represents a valid binary tree with depth less than 5.",
        "nums is sorted in ascending order."
      ]
    },
    {
      "task_id": "sum-of-scores-of-built-strings",
      "problem_description": "You are building a string s of length n one character at a time, prepending each new character to the front of the string. The score of si is the length of the longest common prefix between si and sn. Given the final string s, return the sum of the score of every si.",
      "examples": [
        "Input: s = \"babab\"\nOutput: 9",
        "Input: s = \"azbazbzaz\"\nOutput: 14"
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "camelcase-matching",
      "problem_description": "Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise. A query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all.",
      "examples": [
        "Input: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"\nOutput: [true,false,true,true,false]",
        "Input: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"\nOutput: [true,false,true,false,false]",
        "Input: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"\nOutput: [false,true,false,false,false]"
      ],
      "constraints": [
        "1 <= pattern.length, queries.length <= 100",
        "1 <= queries[i].length <= 100",
        "queries[i] and pattern consist of English letters."
      ]
    },
    {
      "task_id": "find-all-good-strings",
      "problem_description": "Given the strings s1 and s2 of size n and the string evil, return the number of good strings. A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 10^9 + 7.",
      "examples": [
        "Input: n = 2, s1 = \"aa\", s2 = \"da\", evil = \"b\"\nOutput: 51",
        "Input: n = 8, s1 = \"leetcode\", s2 = \"leetgoes\", evil = \"leet\"\nOutput: 0",
        "Input: n = 2, s1 = \"gx\", s2 = \"gz\", evil = \"x\"\nOutput: 2"
      ],
      "constraints": [
        "s1.length == n",
        "s2.length == n",
        "s1 <= s2",
        "1 <= n <= 500",
        "1 <= evil.length <= 50",
        "All strings consist of lowercase English letters."
      ]
    },
    {
      "task_id": "repeated-string-match",
      "problem_description": "Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b to be a substring of a after repeating it, return -1.",
      "examples": [
        "Input: a = \"abcd\", b = \"cdabcdab\"\nOutput: 3\nExplanation: We return 3 because by repeating a three times \"abcdabcdabcd\", b is a substring of it.",
        "Input: a = \"a\", b = \"aa\"\nOutput: 2"
      ],
      "constraints": [
        "1 <= a.length, b.length <= 104",
        "a and b consist of lowercase English letters."
      ]
    },
    {
      "task_id": "string-matching-in-an-array",
      "problem_description": "Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.",
      "examples": [
        "Input: words = [\"mass\",\"as\",\"hero\",\"superhero\"]\nOutput: [\"as\",\"hero\"]",
        "Input: words = [\"leetcode\",\"et\",\"code\"]\nOutput: [\"et\",\"code\"]",
        "Input: words = [\"blue\",\"green\",\"bu\"]\nOutput: []"
      ],
      "constraints": [
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 30",
        "words[i] contains only lowercase English letters.",
        "All the strings of words are unique."
      ]
    },
    {
      "task_id": "number-of-ways-to-arrive-at-destination",
      "problem_description": "You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time. Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]",
        "Output: 4",
        "Input: n = 2, roads = [[1,0,10]]",
        "Output: 1"
      ],
      "constraints": [
        "1 <= n <= 200",
        "n - 1 <= roads.length <= n * (n - 1) / 2",
        "roads[i].length == 3",
        "0 <= ui, vi <= n - 1",
        "1 <= timei <= 10^9",
        "ui != vi",
        "There is at most one road connecting any two intersections.",
        "You can reach any intersection from any other intersection."
      ]
    },
    {
      "task_id": "reachable-nodes-in-subdivided-graph",
      "problem_description": "You are given an undirected graph (the \"original graph\") with n nodes labeled from 0 to n - 1. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge. The graph is given as a 2D array of edges where edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui and vi in the original graph, and cnti is the total number of new nodes that you will subdivide the edge into. Note that cnti == 0 means you will not subdivide the edge. To subdivide the edge [ui, vi], replace it with (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ..., xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi]. In this new graph, you want to know how many nodes are reachable from the node 0, where a node is reachable if the distance is maxMoves or less.",
      "examples": [
        "Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\nOutput: 13",
        "Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\nOutput: 23",
        "Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\nOutput: 1"
      ],
      "constraints": [
        "0 <= edges.length <= min(n * (n - 1) / 2, 104)",
        "edges[i].length == 3",
        "0 <= ui < vi < n",
        "There are no multiple edges in the graph.",
        "0 <= cnti <= 104",
        "0 <= maxMoves <= 109",
        "1 <= n <= 3000"
      ]
    },
    {
      "task_id": "minimum-cost-to-reach-city-with-discounts",
      "problem_description": "A series of highways connect n cities numbered from 0 to n - 1. You are given a 2D integer array highways where highways[i] = [city1i, city2i, tolli] indicates that there is a highway that connects city1i and city2i, allowing a car to go from city1i to city2i and vice versa for a cost of tolli. You are also given an integer discounts which represents the number of discounts you have. You can use a discount to travel across the ith highway for a cost of tolli / 2 (integer division). Each discount may only be used once, and you can only use at most one discount per highway. Return the minimum total cost to go from city 0 to city n - 1, or -1 if it is not possible to go from city 0 to city n - 1.",
      "examples": [
        "Input: n = 5, highways = [[0,1,4],[2,1,3],[1,4,11],[3,2,3],[3,4,2]], discounts = 1\nOutput: 9",
        "Input: n = 4, highways = [[1,3,17],[1,2,7],[3,2,5],[0,1,6],[3,0,20]], discounts = 20\nOutput: 8",
        "Input: n = 4, highways = [[0,1,3],[2,3,2]], discounts = 0\nOutput: -1"
      ],
      "constraints": [
        "2 <= n <= 1000",
        "1 <= highways.length <= 1000",
        "highways[i].length == 3",
        "0 <= city1i, city2i <= n - 1",
        "city1i != city2i",
        "0 <= tolli <= 105",
        "0 <= discounts <= 500",
        "There are no duplicate highways."
      ]
    },
    {
      "task_id": "number-of-possible-sets-of-closing-branches",
      "problem_description": "There is a company with n branches across the country, some of which are connected by roads. Initially, all branches are reachable from each other by traveling some roads. The company has realized that they are spending an excessive amount of time traveling between their branches. As a result, they have decided to close down some of these branches (possibly none). However, they want to ensure that the remaining branches have a distance of at most maxDistance from each other. The distance between two branches is the minimum total traveled length needed to reach one branch from another. You are given integers n, maxDistance, and a 0-indexed 2D array roads, where roads[i] = [ui, vi, wi] represents the undirected road between branches ui and vi with length wi. Return the number of possible sets of closing branches, so that any branch has a distance of at most maxDistance from any other. Note that, after closing a branch, the company will no longer have access to any roads connected to it.",
      "examples": [
        "Input: n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]] Output: 5",
        "Input: n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]] Output: 7",
        "Input: n = 1, maxDistance = 10, roads = [] Output: 2"
      ],
      "constraints": [
        "1 <= n <= 10",
        "1 <= maxDistance <= 105",
        "0 <= roads.length <= 1000",
        "roads[i].length == 3",
        "0 <= ui, vi <= n - 1",
        "ui != vi",
        "1 <= wi <= 1000",
        "All branches are reachable from each other by traveling some roads."
      ]
    },
    {
      "task_id": "cheapest-flights-within-k-stops",
      "problem_description": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.",
      "examples": [
        "Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700",
        "Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200",
        "Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500"
      ],
      "constraints": [
        "1 <= n <= 100",
        "0 <= flights.length <= (n * (n - 1) / 2)",
        "flights[i].length == 3",
        "0 <= fromi, toi < n",
        "fromi != toi",
        "1 <= pricei <= 104",
        "There will not be any multiple flights between two cities.",
        "0 <= src, dst, k < n",
        "src != dst"
      ]
    },
    {
      "task_id": "minimum-add-to-make-parentheses-valid",
      "problem_description": "A parentheses string is valid if and only if: It is the empty string, It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string. Return the minimum number of moves required to make s valid.",
      "examples": [
        "Input: s = \"())\"\nOutput: 1",
        "Input: s = \"((\"\nOutput: 3"
      ],
      "constraints": [
        "1 <= s.length <= 1000",
        "s[i] is either '(' or ')'"
      ]
    },
    {
      "task_id": "check-if-a-string-can-break-another-string",
      "problem_description": "Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.",
      "examples": [
        "Input: s1 = \"abc\", s2 = \"xya\"\nOutput: true\nExplanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\".",
        "Input: s1 = \"abe\", s2 = \"acd\"\nOutput: false\nExplanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.",
        "Input: s1 = \"leetcodee\", s2 = \"interview\"\nOutput: true"
      ],
      "constraints": [
        "s1.length == n",
        "s2.length == n",
        "1 <= n <= 10^5",
        "All strings consist of lowercase English letters."
      ]
    },
    {
      "task_id": "latest-time-you-can-obtain-after-replacing-characters",
      "problem_description": "You are given a string s representing a 12-hour format time where some of the digits (possibly none) are replaced with a \"?\". 12-hour times are formatted as \"HH:MM\", where HH is between 00 and 11, and MM is between 00 and 59. The earliest 12-hour time is 00:00, and the latest is 11:59. You have to replace all the \"?\" characters in s with digits such that the time we obtain by the resulting string is a valid 12-hour format time and is the latest possible. Return the resulting string.",
      "examples": [
        "Input: s = \"1?:?4\"\nOutput: \"11:54\"",
        "Input: s = \"0?:5?\"\nOutput: \"09:59\""
      ],
      "constraints": [
        "s.length == 5",
        "s[2] is equal to the character \":\".",
        "All characters except s[2] are digits or \"?\" characters.",
        "The input is generated such that there is at least one time between \"00:00\" and \"11:59\" that you can obtain after replacing the \"?\" characters."
      ]
    },
    {
      "task_id": "roman-to-integer",
      "problem_description": "Given a roman numeral, convert it to an integer.",
      "examples": [
        "Input: s = \"III\"\nOutput: 3\nExplanation: III = 3.",
        "Input: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.",
        "Input: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4."
      ],
      "constraints": [
        "1 <= s.length <= 15",
        "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
        "It is guaranteed that s is a valid roman numeral in the range [1, 3999]."
      ]
    },
    {
      "task_id": "longest-palindromic-subsequence-ii",
      "problem_description": "A subsequence of a string s is considered a good palindromic subsequence if it is a subsequence of s, it is a palindrome, it has an even length, and no two consecutive characters are equal, except the two middle ones. Given a string s, return the length of the longest good palindromic subsequence in s.",
      "examples": [
        "Input: s = \"bbabab\"\nOutput: 4\nExplanation: The longest good palindromic subsequence of s is \"baab\".",
        "Input: s = \"dcbccacdb\"\nOutput: 4\nExplanation: The longest good palindromic subsequence of s is \"dccd\"."
      ],
      "constraints": [
        "1 <= s.length <= 250",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "corporate-flight-bookings",
      "problem_description": "There are n flights that are labeled from 1 to n. You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range. Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
      "examples": [
        "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]",
        "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]"
      ],
      "constraints": [
        "1 <= n <= 2 * 10^4",
        "1 <= bookings.length <= 2 * 10^4",
        "bookings[i].length == 3",
        "1 <= firsti <= lasti <= n",
        "1 <= seatsi <= 10^4"
      ]
    },
    {
      "task_id": "minimum-time-visiting-all-points",
      "problem_description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move according to these rules: In 1 second, you can either: move vertically by one unit, move horizontally by one unit, or move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points that appear later in the order, but these do not count as visits.",
      "examples": [
        "Input: points = [[1,1],[3,4],[-1,0]]\nOutput: 7\nExplanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   Time from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds",
        "Input: points = [[3,2],[-2,2]]\nOutput: 5"
      ],
      "constraints": [
        "points.length == n",
        "1 <= n <= 100",
        "points[i].length == 2",
        "-1000 <= points[i][0], points[i][1] <= 1000"
      ]
    },
    {
      "task_id": "maximum-number-of-jumps-to-reach-the-last-index",
      "problem_description": "You are given a 0-indexed array nums of n integers and an integer target. You are initially positioned at index 0. In one step, you can jump from index i to any index j such that: 0 <= i < j < n -target <= nums[j] - nums[i] <= target. Return the maximum number of jumps you can make to reach index n - 1. If there is no way to reach index n - 1, return -1.",
      "examples": [
        "Input: nums = [1,3,6,4,1,2], target = 2\nOutput: 3",
        "Input: nums = [1,3,6,4,1,2], target = 3\nOutput: 5",
        "Input: nums = [1,3,6,4,1,2], target = 0\nOutput: -1"
      ],
      "constraints": [
        "2 <= nums.length == n <= 1000",
        "-109 <= nums[i] <= 109",
        "0 <= target <= 2 * 109"
      ]
    },
    {
      "task_id": "count-submatrices-with-equal-frequency-of-x-and-y",
      "problem_description": "Given a 2D character matrix grid, where grid[i][j] is either 'X', 'Y', or '.', return the number of submatrices that contain: grid[0][0], an equal frequency of 'X' and 'Y', at least one 'X'.",
      "examples": [
        "Input: grid = [[\"X\",\"Y\",\".\"],[\"Y\",\".\",\".\"]]\nOutput: 3",
        "Input: grid = [[\"X\",\"X\"],[\"X\",\"Y\"]]\nOutput: 0",
        "Input: grid = [[\".\",\".\"],[\".\",\".\"]]\nOutput: 0"
      ],
      "constraints": [
        "1 <= grid.length, grid[i].length <= 1000",
        "grid[i][j] is either 'X', 'Y', or '.'"
      ]
    },
    {
      "task_id": "find-missing-and-repeated-values",
      "problem_description": "You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b. Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.",
      "examples": [
        "Input: grid = [[1,3],[2,2]]\nOutput: [2,4]",
        "Input: grid = [[9,1,7],[8,9,2],[3,4,6]]\nOutput: [9,5]"
      ],
      "constraints": [
        "2 <= n == grid.length == grid[i].length <= 50",
        "1 <= grid[i][j] <= n * n",
        "For all x that 1 <= x <= n * n there is exactly one x that is not equal to any of the grid members.",
        "For all x that 1 <= x <= n * n there is exactly one x that is equal to exactly two of the grid members.",
        "For all x that 1 <= x <= n * n except two of them there is exactly one pair of i, j that 0 <= i, j <= n - 1 and grid[i][j] == x."
      ]
    },
    {
      "task_id": "divisor-game",
      "problem_description": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of: Choosing any x with 0 < x < n and n % x == 0. Replacing the number n on the chalkboard with n - x. Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally.",
      "examples": [
        "Input: n = 2\nOutput: true\nExplanation: Alice chooses 1, and Bob has no more moves.",
        "Input: n = 3\nOutput: false\nExplanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves."
      ],
      "constraints": [
        "1 <= n <= 1000"
      ]
    },
    {
      "task_id": "movement-of-robots",
      "problem_description": "Some robots are standing on an infinite number line with their initial coordinates given by a 0-indexed integer array nums and will start moving once given the command to move. The robots will move a unit distance each second. You are given a string s denoting the direction in which robots will move on command. 'L' means the robot will move towards the left side or negative side of the number line, whereas 'R' means the robot will move towards the right side or positive side of the number line. If two robots collide, they will start moving in opposite directions. Return the sum of distances between all the pairs of robots d seconds after the command. Since the sum can be very large, return it modulo 10^9 + 7. For two robots at the index i and j, pair (i,j) and pair (j,i) are considered the same pair. When robots collide, they instantly change their directions without wasting any time. Collision happens when two robots share the same place in a moment.",
      "examples": [
        "Input: nums = [-2,0,2], s = \"RLL\", d = 3\nOutput: 8",
        "Input: nums = [1,0], s = \"RL\", d = 2\nOutput: 5"
      ],
      "constraints": [
        "2 <= nums.length <= 105",
        "-2 * 10^9 <= nums[i] <= 2 * 10^9",
        "0 <= d <= 10^9",
        "nums.length == s.length",
        "s consists of 'L' and 'R' only",
        "nums[i] will be unique."
      ]
    },
    {
      "task_id": "vowels-game-in-a-string",
      "problem_description": "Alice and Bob are playing a game on a string. You are given a string s, Alice and Bob will take turns playing the following game where Alice starts first: On Alice's turn, she has to remove any non-empty substring from s that contains an odd number of vowels. On Bob's turn, he has to remove any non-empty substring from s that contains an even number of vowels. The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally. The English vowels are: a, e, i, o, and u.",
      "examples": [
        "Input: s = \"leetcoder\"\nOutput: true\nExplanation:\nAlice can win the game as follows:\n\nAlice plays first, she can delete the underlined substring in s = \"leetcoder\" which contains 3 vowels. The resulting string is s = \"der\".\nBob plays second, he can delete the underlined substring in s = \"der\" which contains 0 vowels. The resulting string is s = \"er\".\nAlice plays third, she can delete the whole string s = \"er\" which contains 1 vowel.\nBob plays fourth, since the string is empty, there is no valid play for Bob. So Alice wins the game.",
        "Input: s = \"bbcd\"\nOutput: false\nExplanation:\nThere is no valid play for Alice in her first turn, so Alice loses the game."
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "airplane-seat-assignment-probability",
      "problem_description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: Take their own seat if it is still available, and Pick other seats randomly when they find their seat occupied. Return the probability that the nth person gets his own seat.",
      "examples": [
        "Input: n = 1\nOutput: 1.00000\nExplanation: The first person can only get the first seat.",
        "Input: n = 2\nOutput: 0.50000\nExplanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat)."
      ],
      "constraints": [
        "1 <= n <= 105"
      ]
    },
    {
      "task_id": "game-of-nim",
      "problem_description": "Alice and Bob take turns playing a game with Alice starting first. In this game, there are n piles of stones. On each player's turn, the player should remove any positive number of stones from a non-empty pile of his or her choice. The first player who cannot make a move loses, and the other player wins. Given an integer array piles, where piles[i] is the number of stones in the ith pile, return true if Alice wins, or false if Bob wins. Both Alice and Bob play optimally.",
      "examples": [
        "Input: piles = [1]\nOutput: true",
        "Input: piles = [1,1]\nOutput: false",
        "Input: piles = [1,2,3]\nOutput: false"
      ],
      "constraints": [
        "n == piles.length",
        "1 <= n <= 7",
        "1 <= piles[i] <= 7"
      ]
    },
    {
      "task_id": "remove-zero-sum-consecutive-nodes-from-linked-list",
      "problem_description": "Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences. After doing so, return the head of the final linked list. You may return any such answer.",
      "examples": [
        "Input: head = [1,2,-3,3,1]\nOutput: [3,1]",
        "Input: head = [1,2,3,-3,4]\nOutput: [1,2,4]",
        "Input: head = [1,2,3,-3,-2]\nOutput: [1]"
      ],
      "constraints": [
        "The given linked list will contain between 1 and 1000 nodes.",
        "Each node in the linked list has -1000 <= node.val <= 1000."
      ]
    },
    {
      "task_id": "convert-sorted-list-to-binary-search-tree",
      "problem_description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
      "examples": [
        "Input: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]",
        "Input: head = []\nOutput: []"
      ],
      "constraints": [
        "The number of nodes in head is in the range [0, 2 * 104].",
        "-105 <= Node.val <= 105"
      ]
    },
    {
      "task_id": "linked-list-cycle",
      "problem_description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false.",
      "examples": [
        "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
        "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
        "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
      ],
      "constraints": [
        "The number of the nodes in the list is in the range [0, 104].",
        "-105 <= Node.val <= 105",
        "pos is -1 or a valid index in the linked-list."
      ]
    },
    {
      "task_id": "palindrome-linked-list",
      "problem_description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
      "examples": [
        "Input: head = [1,2,2,1]\nOutput: true",
        "Input: head = [1,2]\nOutput: false"
      ],
      "constraints": [
        "The number of nodes in the list is in the range [1, 105].",
        "0 <= Node.val <= 9"
      ]
    },
    {
      "task_id": "linked-list-components",
      "problem_description": "You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values. Return the number of connected components in nums where two values are connected if they appear consecutively in the linked list.",
      "examples": [
        "Input: head = [0,1,2,3], nums = [0,1,3]\nOutput: 2",
        "Input: head = [0,1,2,3,4], nums = [0,3,1,4]\nOutput: 2"
      ],
      "constraints": [
        "The number of nodes in the linked list is n.",
        "1 <= n <= 104",
        "0 <= Node.val < n",
        "All the values Node.val are unique.",
        "1 <= nums.length <= n",
        "0 <= nums[i] < n",
        "All the values of nums are unique."
      ]
    },
    {
      "task_id": "largest-color-value-in-a-directed-graph",
      "problem_description": "There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1. You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj. A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.",
      "examples": [
        "Input: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\r\nOutput: 3\r\nExplanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).",
        "Input: colors = \"a\", edges = [[0,0]]\r\nOutput: -1\r\nExplanation: There is a cycle from 0 to 0."
      ],
      "constraints": [
        "n == colors.length",
        "m == edges.length",
        "1 <= n <= 105",
        "0 <= m <= 105",
        "colors consists of lowercase English letters.",
        "0 <= aj, bj < n"
      ]
    },
    {
      "task_id": "tree-diameter",
      "problem_description": "The diameter of a tree is the number of edges in the longest path in that tree. There is an undirected tree of n nodes labeled from 0 to n - 1. You are given a 2D array edges where edges.length == n - 1 and edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the tree. Return the diameter of the tree.",
      "examples": [
        "Input: edges = [[0,1],[0,2]]\nOutput: 2\nExplanation: The longest path of the tree is the path 1 - 0 - 2.",
        "Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]\nOutput: 4\nExplanation: The longest path of the tree is the path 3 - 2 - 1 - 4 - 5."
      ],
      "constraints": [
        "n == edges.length + 1",
        "1 <= n <= 104",
        "0 <= ai, bi < n",
        "ai != bi"
      ]
    },
    {
      "task_id": "find-all-possible-recipes-from-given-supplies",
      "problem_description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. A recipe can also be an ingredient for other recipes, i.e., ingredients[i] may contain a string that is in recipes. You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them. Return a list of all the recipes that you can create. You may return the answer in any order. Note that two recipes may contain each other in their ingredients.",
      "examples": [
        "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]",
        "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]",
        "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]"
      ],
      "constraints": [
        "n == recipes.length == ingredients.length",
        "1 <= n <= 100",
        "1 <= ingredients[i].length, supplies.length <= 100",
        "1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10",
        "recipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.",
        "All the values of recipes and supplies combined are unique.",
        "Each ingredients[i] does not contain any duplicate values."
      ]
    },
    {
      "task_id": "cat-and-mouse",
      "problem_description": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are. Additionally, it is not allowed for the Cat to travel to the Hole (node 0). The game can end in three ways: If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated, the game is a draw. Given a graph, and assuming both players play optimally, return 1 if the mouse wins the game, 2 if the cat wins the game, or 0 if the game is a draw.",
      "examples": [
        "Input: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0",
        "Input: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1"
      ],
      "constraints": [
        "3 <= graph.length <= 50",
        "1 <= graph[i].length < graph.length",
        "0 <= graph[i][j] < graph.length",
        "graph[i][j] != i",
        "graph[i] is unique.",
        "The mouse and the cat can always move."
      ]
    },
    {
      "task_id": "cat-and-mouse-ii",
      "problem_description": "A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food. Players are represented by the characters 'C'(Cat),'M'(Mouse). Floors are represented by the character '.' and can be walked on. Walls are represented by the character '#' and cannot be walked on. Food is represented by the character 'F' and can be walked on. There is only one of each character 'C', 'M', and 'F' in grid. Mouse and Cat play according to the following rules: Mouse moves first, then they take turns to move. During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid. catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length. Staying in the same position is allowed. Mouse can jump over Cat. The game can end in 4 ways: If Cat occupies the same position as Mouse, Cat wins. If Cat reaches the food first, Cat wins. If Mouse reaches the food first, Mouse wins. If Mouse cannot get to the food within 1000 turns, Cat wins. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.",
      "examples": [
        "Input: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\nOutput: true\nExplanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.",
        "Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\nOutput: true",
        "Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\nOutput: false"
      ],
      "constraints": [
        "rows == grid.length",
        "cols = grid[i].length",
        "1 <= rows, cols <= 8",
        "grid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.",
        "There is only one of each character 'C', 'M', and 'F' in grid.",
        "1 <= catJump, mouseJump <= 8"
      ]
    },
    {
      "task_id": "expression-add-operators",
      "problem_description": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value. Note that operands in the returned expressions should not contain leading zeros.",
      "examples": [
        "Input: num = \"123\", target = 6\nOutput: [\"1*2*3\",\"1+2+3\"]",
        "Input: num = \"232\", target = 8\nOutput: [\"2*3+2\",\"2+3*2\"]",
        "Input: num = \"3456237490\", target = 9191\nOutput: []"
      ],
      "constraints": [
        "1 <= num.length <= 10",
        "num consists of only digits.",
        "-231 <= target <= 231 - 1"
      ]
    },
    {
      "task_id": "word-break-ii",
      "problem_description": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
      "examples": [
        "Input: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]",
        "Input: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]",
        "Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []"
      ],
      "constraints": [
        "1 <= s.length <= 20",
        "1 <= wordDict.length <= 1000",
        "1 <= wordDict[i].length <= 10",
        "s and wordDict[i] consist of only lowercase English letters.",
        "All the strings of wordDict are unique.",
        "Input is generated in a way that the length of the answer doesn't exceed 10^5."
      ]
    },
    {
      "task_id": "palindrome-permutation-ii",
      "problem_description": "Given a string s, return all the palindromic permutations (without duplicates) of it. You may return the answer in any order. If s has no palindromic permutation, return an empty list.",
      "examples": [
        "Input: s = \"aabb\"\nOutput: [\"abba\",\"baab\"]",
        "Input: s = \"abc\"\nOutput: []"
      ],
      "constraints": [
        "1 <= s.length <= 16",
        "s consists of only lowercase English letters."
      ]
    },
    {
      "task_id": "fair-distribution-of-cookies",
      "problem_description": "You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up. The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution. Return the minimum unfairness of all distributions.",
      "examples": [
        "Input: cookies = [8,15,10,20,8], k = 2\nOutput: 31",
        "Input: cookies = [6,1,3,2,2,4,1,2], k = 3\nOutput: 7"
      ],
      "constraints": [
        "2 <= cookies.length <= 8",
        "1 <= cookies[i] <= 105",
        "2 <= k <= cookies.length"
      ]
    },
    {
      "task_id": "android-unlock-patterns",
      "problem_description": "Android devices have a special lock screen with a 3 x 3 grid of dots. Users can set an 'unlock pattern' by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of k dots is a valid unlock pattern if both of the following are true: All the dots in the sequence are distinct. If the line segment connecting two consecutive dots in the sequence passes through the center of any other dot, the other dot must have previously appeared in the sequence. No jumps through the center non-selected dots are allowed. Given two integers m and n, return the number of unique and valid unlock patterns of the Android grid lock screen that consist of at least m keys and at most n keys. Two unlock patterns are considered unique if there is a dot in one sequence that is not in the other, or the order of the dots is different.",
      "examples": [
        "Input: m = 1, n = 1\nOutput: 9",
        "Input: m = 1, n = 2\nOutput: 65"
      ],
      "constraints": [
        "1 <= m, n <= 9"
      ]
    },
    {
      "task_id": "count-k-subsequences-of-a-string-with-maximum-beauty",
      "problem_description": "You are given a string s and an integer k. A k-subsequence is a subsequence of s, having length k, and all its characters are unique, i.e., every character occurs once. Let f(c) denote the number of times the character c occurs in s. The beauty of a k-subsequence is the sum of f(c) for every character c in the k-subsequence. Return an integer denoting the number of k-subsequences whose beauty is the maximum among all k-subsequences. A subsequence of a string is a new string formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters. Two k-subsequences are considered different if one is formed by an index that is not present in the other. So, two k-subsequences may form the same string.",
      "examples": [
        "Input: s = \"bcca\", k = 2\nOutput: 4\n",
        "Input: s = \"abbcd\", k = 4\nOutput: 2\n"
      ],
      "constraints": [
        "1 <= s.length <= 2 * 105",
        "1 <= k <= s.length",
        "s consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "unique-paths",
      "problem_description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 10^9.",
      "examples": [
        "Input: m = 3, n = 7\nOutput: 28",
        "Input: m = 3, n = 2\nOutput: 3"
      ],
      "constraints": [
        "1 <= m, n <= 100"
      ]
    },
    {
      "task_id": "poor-pigs",
      "problem_description": "There are buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of pigs the liquid to see whether they will die or not. You only have minutesToTest minutes to determine which bucket is poisonous. You can feed the pigs according to these steps: Choose some live pigs to feed. For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs. Wait for minutesToDie minutes. You may not feed any other pigs during this time. After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive. Repeat this process until you run out of time. Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.",
      "examples": [
        "Input: buckets = 4, minutesToDie = 15, minutesToTest = 15\nOutput: 2",
        "Input: buckets = 4, minutesToDie = 15, minutesToTest = 30\nOutput: 2"
      ],
      "constraints": [
        "1 <= buckets <= 1000",
        "1 <= minutesToDie <= minutesToTest <= 100"
      ]
    },
    {
      "task_id": "ugly-number-iii",
      "problem_description": "An ugly number is a positive integer that is divisible by a, b, or c. Given four integers n, a, b, and c, return the nth ugly number.",
      "examples": [
        "Input: n = 3, a = 2, b = 3, c = 5\nOutput: 4",
        "Input: n = 4, a = 2, b = 3, c = 4\nOutput: 6",
        "Input: n = 5, a = 2, b = 11, c = 13\nOutput: 10"
      ],
      "constraints": [
        "1 <= n, a, b, c <= 10^9",
        "1 <= a * b * c <= 10^18",
        "It is guaranteed that the result will be in range [1, 2 * 10^9]"
      ]
    },
    {
      "task_id": "sum-of-all-subset-xor-totals",
      "problem_description": "The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty. Given an array nums, return the sum of all XOR totals for every subset of nums. Note: Subsets with the same elements should be counted multiple times. An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.",
      "examples": [
        "Input: nums = [1,3]\nOutput: 6\nExplanation: The 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6",
        "Input: nums = [5,1,6]\nOutput: 28\nExplanation: The 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28",
        "Input: nums = [3,4,5,6,7,8]\nOutput: 480\nExplanation: The sum of all XOR totals for every subset is 480."
      ],
      "constraints": [
        "1 <= nums.length <= 12",
        "1 <= nums[i] <= 20"
      ]
    },
    {
      "task_id": "reconstruct-itinerary",
      "problem_description": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from 'JFK', thus, the itinerary must begin with 'JFK'. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
      "examples": [
        "Input: tickets = [[MUC,LHR],[JFK,MUC],[SFO,SJC],[LHR,SFO]]\nOutput: [JFK,MUC,LHR,SFO,SJC]",
        "Input: tickets = [[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]\nOutput: [JFK,ATL,JFK,SFO,ATL,SFO]"
      ],
      "constraints": [
        "1 <= tickets.length <= 300",
        "tickets[i].length == 2",
        "fromi.length == 3",
        "toi.length == 3",
        "fromi and toi consist of uppercase English letters.",
        "fromi != toi"
      ]
    },
    {
      "task_id": "valid-arrangement-of-pairs",
      "problem_description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti. Return any valid arrangement of pairs. The inputs will be generated such that there exists a valid arrangement of pairs.",
      "examples": [
        "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]",
        "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]",
        "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]"
      ],
      "constraints": [
        "1 <= pairs.length <= 105",
        "pairs[i].length == 2",
        "0 <= starti, endi <= 109",
        "starti != endi",
        "No two pairs are exactly the same.",
        "There exists a valid arrangement of pairs."
      ]
    },
    {
      "task_id": "cracking-the-safe",
      "problem_description": "There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1]. The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit. Return any string of minimum length that will unlock the safe at some point of entering it.",
      "examples": [
        "Input: n = 1, k = 2\nOutput: \"10\"",
        "Input: n = 2, k = 2\nOutput: \"01100\""
      ],
      "constraints": [
        "1 <= n <= 4",
        "1 <= k <= 10",
        "1 <= kn <= 4096"
      ]
    },
    {
      "task_id": "make-array-empty",
      "problem_description": "You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty: If the first element has the smallest value, remove it. Otherwise, put the first element at the end of the array. Return an integer denoting the number of operations it takes to make nums empty.",
      "examples": [
        "Input: nums = [3,4,-1]\nOutput: 5\n\nOperation\nArray\n\n1\n[4, -1, 3]\n\n2\n[-1, 3, 4]\n\n3\n[3, 4]\n\n4\n[4]\n\n5\n[]",
        "Input: nums = [1,2,4,3]\nOutput: 5\n\nOperation\nArray\n\n1\n[2, 4, 3]\n\n2\n[4, 3]\n\n3\n[3, 4]\n\n4\n[4]\n\n5\n[]",
        "Input: nums = [1,2,3]\nOutput: 3\n\nOperation\nArray\n\n1\n[2, 3]\n\n2\n[3]\n\n3\n[]"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-109 <= nums[i] <= 109",
        "All values in nums are distinct."
      ]
    },
    {
      "task_id": "number-of-longest-increasing-subsequence",
      "problem_description": "Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing.",
      "examples": [
        "Input: nums = [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].",
        "Input: nums = [2,2,2,2,2]\nOutput: 5\nExplanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5."
      ],
      "constraints": [
        "1 <= nums.length <= 2000",
        "-106 <= nums[i] <= 106",
        "The answer is guaranteed to fit inside a 32-bit integer."
      ]
    },
    {
      "task_id": "find-building-where-alice-and-bob-can-meet",
      "problem_description": "You are given a 0-indexed array heights of positive integers, where heights[i] represents the height of the ith building. If a person is in building i, they can move to any other building j if and only if i < j and heights[i] < heights[j]. You are also given another array queries where queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob is in building bi. Return an array ans where ans[i] is the index of the leftmost building where Alice and Bob can meet on the ith query. If Alice and Bob cannot move to a common building on query i, set ans[i] to -1.",
      "examples": [
        "Input: heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]] Output: [2,5,-1,5,2]",
        "Input: heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]] Output: [7,6,-1,4,6]"
      ],
      "constraints": [
        "1 <= heights.length <= 5 * 10^4",
        "1 <= heights[i] <= 10^9",
        "1 <= queries.length <= 5 * 10^4",
        "queries[i] = [ai, bi]",
        "0 <= ai, bi <= heights.length - 1"
      ]
    },
    {
      "task_id": "count-number-of-teams",
      "problem_description": "There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]). A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n). Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).",
      "examples": [
        "Input: rating = [2,5,3,4,1]\nOutput: 3\nExplanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1).",
        "Input: rating = [2,1,3]\nOutput: 0\nExplanation: We can't form any team given the conditions.",
        "Input: rating = [1,2,3,4]\nOutput: 4"
      ],
      "constraints": [
        "n == rating.length",
        "3 <= n <= 1000",
        "1 <= rating[i] <= 105",
        "All the integers in rating are unique."
      ]
    },
    {
      "task_id": "find-the-index-of-permutation",
      "problem_description": "Given an array perm of length n which is a permutation of [1, 2, ..., n], return the index of perm in the lexicographically sorted array of all of the permutations of [1, 2, ..., n]. Since the answer may be very large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: perm = [1,2]\nOutput: 0\n",
        "Input: perm = [3,1,2]\nOutput: 4\n"
      ],
      "constraints": [
        "1 <= n == perm.length <= 10^5",
        "perm is a permutation of [1, 2, ..., n]."
      ]
    },
    {
      "task_id": "check-for-contradictions-in-equations",
      "problem_description": "You are given a 2D array of strings equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] means that Ai / Bi = values[i]. Determine if there exists a contradiction in the equations. Return true if there is a contradiction, or false otherwise.",
      "examples": [
        "Input: equations = [[a,b],[b,c],[a,c]], values = [3,0.5,1.5]\nOutput: false",
        "Input: equations = [[le,et],[le,code],[code,et]], values = [2,5,0.5]\nOutput: true"
      ],
      "constraints": [
        "1 <= equations.length <= 100",
        "equations[i].length == 2",
        "1 <= Ai.length, Bi.length <= 5",
        "Ai, Bi consist of lowercase English letters.",
        "equations.length == values.length",
        "0.0 < values[i] <= 10.0",
        "values[i] has a maximum of 2 decimal places."
      ]
    },
    {
      "task_id": "paths-in-maze-that-lead-to-same-room",
      "problem_description": "A maze consists of n rooms numbered from 1 to n, and some rooms are connected by corridors. You are given a 2D integer array corridors where corridors[i] = [room1i, room2i] indicates that there is a corridor connecting room1i and room2i, allowing a person in the maze to go from room1i to room2i and vice versa. The designer of the maze wants to know how confusing the maze is. The confusion score of the maze is the number of different cycles of length 3. Two cycles are considered to be different if one or more of the rooms visited in the first cycle is not in the second cycle. Return the confusion score of the maze.",
      "examples": [
        "Input: n = 5, corridors = [[1,2],[5,2],[4,1],[2,4],[3,1],[3,4]] Output: 2",
        "Input: n = 4, corridors = [[1,2],[3,4]] Output: 0"
      ],
      "constraints": [
        "2 <= n <= 1000",
        "1 <= corridors.length <= 5 * 104",
        "corridors[i].length == 2",
        "1 <= room1i, room2i <= n",
        "room1i != room2i",
        "There are no duplicate corridors."
      ]
    },
    {
      "task_id": "maximum-score-of-a-node-sequence",
      "problem_description": "There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 0-indexed integer array scores of length n where scores[i] denotes the score of node i. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi. A node sequence is valid if it meets the following conditions: There is an edge connecting every pair of adjacent nodes in the sequence. No node appears more than once in the sequence. The score of a node sequence is defined as the sum of the scores of the nodes in the sequence. Return the maximum score of a valid node sequence with a length of 4. If no such sequence exists, return -1.",
      "examples": [
        "Input: scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\nOutput: 24",
        "Input: scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\nOutput: -1"
      ],
      "constraints": [
        "n == scores.length",
        "4 <= n <= 5 * 104",
        "1 <= scores[i] <= 108",
        "0 <= edges.length <= 5 * 104",
        "edges[i].length == 2",
        "0 <= ai, bi <= n - 1",
        "ai != bi",
        "There are no duplicate edges."
      ]
    },
    {
      "task_id": "reachable-nodes-in-subdivided-graph",
      "problem_description": "You are given an undirected graph (the \"original graph\") with n nodes labeled from 0 to n - 1. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge. The graph is given as a 2D array of edges where edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui and vi in the original graph, and cnti is the total number of new nodes that you will subdivide the edge into. Note that cnti == 0 means you will not subdivide the edge. To subdivide the edge [ui, vi], replace it with (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ..., xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi]. In this new graph, you want to know how many nodes are reachable from the node 0, where a node is reachable if the distance is maxMoves or less. Given the original graph and maxMoves, return the number of nodes that are reachable from node 0 in the new graph.",
      "examples": [
        "Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\nOutput: 13",
        "Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\nOutput: 23",
        "Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\nOutput: 1"
      ],
      "constraints": [
        "0 <= edges.length <= min(n * (n - 1) / 2, 104)",
        "edges[i].length == 3",
        "0 <= ui < vi < n",
        "There are no multiple edges in the graph.",
        "0 <= cnti <= 104",
        "0 <= maxMoves <= 109",
        "1 <= n <= 3000"
      ]
    },
    {
      "task_id": "find-eventual-safe-states",
      "problem_description": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i]. A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.",
      "examples": [
        "Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]",
        "Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]"
      ],
      "constraints": [
        "n == graph.length",
        "1 <= n <= 104",
        "0 <= graph[i].length <= n",
        "0 <= graph[i][j] <= n - 1",
        "graph[i] is sorted in a strictly increasing order.",
        "The graph may contain self-loops.",
        "The number of edges in the graph will be in the range [1, 4 * 104]."
      ]
    },
    {
      "task_id": "minimum-sum-of-values-by-dividing-array",
      "problem_description": "You are given two arrays nums and andValues of length n and m respectively. The value of an array is equal to the last element of that array. You have to divide nums into m disjoint contiguous subarrays such that for the ith subarray [li, ri], the bitwise AND of the subarray elements is equal to andValues[i], in other words, nums[li] & nums[li + 1] & ... & nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise AND operator. Return the minimum possible sum of the values of the m subarrays nums is divided into. If it is not possible to divide nums into m subarrays satisfying these conditions, return -1.",
      "examples": [
        "Input: nums = [1,4,3,3,2], andValues = [0,3,3,2]\nOutput: 12",
        "Input: nums = [2,3,5,7,7,7,5], andValues = [0,7,5]\nOutput: 17",
        "Input: nums = [1,2,3,4], andValues = [2]\nOutput: -1"
      ],
      "constraints": [
        "1 <= n == nums.length <= 104",
        "1 <= m == andValues.length <= min(n, 10)",
        "1 <= nums[i] < 105",
        "0 <= andValues[j] < 105"
      ]
    },
    {
      "task_id": "maximum-number-of-tasks-you-can-assign",
      "problem_description": "You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]). Additionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill. Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.",
      "examples": [
        "Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\nOutput: 3",
        "Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\nOutput: 1",
        "Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\nOutput: 2"
      ],
      "constraints": [
        "n == tasks.length",
        "m == workers.length",
        "1 <= n, m <= 5 * 104",
        "0 <= pills <= m",
        "0 <= tasks[i], workers[j], strength <= 10^9"
      ]
    },
    {
      "task_id": "number-of-people-aware-of-a-secret",
      "problem_description": "On day 1, one person discovers a secret. You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards. Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: n = 6, delay = 2, forget = 4\nOutput: 5",
        "Input: n = 4, delay = 1, forget = 3\nOutput: 6"
      ],
      "constraints": [
        "2 <= n <= 1000",
        "1 <= delay < forget <= n"
      ]
    },
    {
      "task_id": "jump-game-vi",
      "problem_description": "You are given a 0-indexed integer array nums and an integer k. You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive. You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array. Return the maximum score you can get.",
      "examples": [
        "Input: nums = [1,-1,-2,4,-7,3], k = 2\nOutput: 7",
        "Input: nums = [10,-5,-2,4,0,3], k = 3\nOutput: 17",
        "Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length, k <= 105",
        "-104 <= nums[i] <= 104"
      ]
    },
    {
      "task_id": "number-of-students-unable-to-eat-lunch",
      "problem_description": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step: If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue. Otherwise, they will leave it and go to the queue's end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i\u200b\u200b\u200b\u200b\u200b\u200bth sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j\u200b\u200b\u200b\u200b\u200b\u200bth student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.",
      "examples": [
        "Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\nOutput: 0",
        "Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\nOutput: 3"
      ],
      "constraints": [
        "1 <= students.length, sandwiches.length <= 100",
        "students.length == sandwiches.length",
        "sandwiches[i] is 0 or 1.",
        "students[i] is 0 or 1."
      ]
    },
    {
      "task_id": "best-position-for-a-service-centre",
      "problem_description": "A delivery company wants to build a new service center in a new city. The company knows the positions of all the customers in this city on a 2D-Map and wants to build the new center in a position such that the sum of the euclidean distances to all customers is minimum. Given an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers. In other words, you need to choose the position of the service center [xcentre, ycentre] such that the following formula is minimized.",
      "examples": [
        "Input: positions = [[0,1],[1,0],[1,2],[2,1]]\nOutput: 4.00000",
        "Input: positions = [[1,1],[3,3]]\nOutput: 2.82843"
      ],
      "constraints": [
        "1 <= positions.length <= 50",
        "positions[i].length == 2",
        "0 <= xi, yi <= 100"
      ]
    },
    {
      "task_id": "find-kth-bit-in-nth-binary-string",
      "problem_description": "Given two positive integers n and k, the binary string Sn is formed as follows: S1 = \"0\" Si = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1. Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0). Return the kth bit in Sn. It is guaranteed that k is valid for the given n.",
      "examples": [
        "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
        "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
      ],
      "constraints": [
        "1 <= n <= 20",
        "1 <= k <= 2n - 1"
      ]
    },
    {
      "task_id": "basic-calculator-iii",
      "problem_description": "Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, '+', '-', '*', '/' operators, and open '(' and closing parentheses ')'. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().",
      "examples": [
        "Input: s = \"1+1\"\nOutput: 2",
        "Input: s = \"6-4/2\"\nOutput: 4",
        "Input: s = \"2*(5+5*2)/3+(6/2+8)\"\nOutput: 21"
      ],
      "constraints": [
        "1 <= s <= 104",
        "s consists of digits, '+', '-', '*', '/', '(', and ')'.",
        "s is a valid expression."
      ]
    },
    {
      "task_id": "different-ways-to-add-parentheses",
      "problem_description": "Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.",
      "examples": [
        "Input: expression = \"2-1-1\"\nOutput: [0,2]",
        "Input: expression = \"2*3-4*5\"\nOutput: [-34,-14,-10,-10,10]"
      ],
      "constraints": [
        "1 <= expression.length <= 20",
        "expression consists of digits and the operator '+', '-', and '*'.",
        "All the integer values in the input expression are in the range [0, 99].",
        "The integer values in the input expression do not have a leading '-' or '+' denoting the sign."
      ]
    },
    {
      "task_id": "add-two-numbers",
      "problem_description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
      "examples": [
        "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]",
        "Input: l1 = [0], l2 = [0]\nOutput: [0]",
        "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
      ],
      "constraints": [
        "The number of nodes in each linked list is in the range [1, 100].",
        "0 <= Node.val <= 9",
        "It is guaranteed that the list represents a number that does not have leading zeros."
      ]
    },
    {
      "task_id": "count-good-numbers",
      "problem_description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7). Given an integer n, return the total number of good digit strings of length n. A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
      "examples": [
        "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
        "Input: n = 4\nOutput: 400",
        "Input: n = 50\nOutput: 564908303"
      ],
      "constraints": [
        "1 <= n <= 1015"
      ]
    },
    {
      "task_id": "number-of-students-unable-to-eat-lunch",
      "problem_description": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step: If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue. Otherwise, they will leave it and go to the queue's end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i\u200b\u200b\u200b\u200b\u200b\u200bth sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j\u200b\u200b\u200b\u200b\u200b\u200bth student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.",
      "examples": [
        "Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\nOutput: 0",
        "Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\nOutput: 3"
      ],
      "constraints": [
        "1 <= students.length, sandwiches.length <= 100",
        "students.length == sandwiches.length",
        "sandwiches[i] is 0 or 1.",
        "students[i] is 0 or 1."
      ]
    },
    {
      "task_id": "add-strings",
      "problem_description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
      "examples": [
        "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
        "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
        "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
      ],
      "constraints": [
        "1 <= num1.length, num2.length <= 104",
        "num1 and num2 consist of only digits.",
        "num1 and num2 don't have any leading zeros except for the zero itself."
      ]
    },
    {
      "task_id": "convert-1d-array-into-2d-array",
      "problem_description": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.",
      "examples": [
        "Input: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]",
        "Input: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]",
        "Input: original = [1,2], m = 1, n = 1\nOutput: []"
      ],
      "constraints": [
        "1 <= original.length <= 5 * 104",
        "1 <= original[i] <= 105",
        "1 <= m, n <= 4 * 104"
      ]
    },
    {
      "task_id": "average-waiting-time",
      "problem_description": "There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]: arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order. timei is the time needed to prepare the order of the ith customer. When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input. Return the average waiting time of all customers.",
      "examples": [
        "Input: customers = [[1,2],[2,5],[4,3]]\nOutput: 5.00000",
        "Input: customers = [[5,2],[5,4],[10,3],[20,1]]\nOutput: 3.25000"
      ],
      "constraints": [
        "1 <= customers.length <= 105",
        "1 <= arrivali, timei <= 104",
        "arrivali <= arrivali+1"
      ]
    },
    {
      "task_id": "meeting-rooms-iii",
      "problem_description": "You are given an integer n. There are n rooms numbered from 0 to n - 1. You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique. Meetings are allocated to rooms in the following manner: Each meeting will take place in the unused room with the lowest number. If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting. When a room becomes unused, meetings that have an earlier original start time should be given the room. Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number. A half-closed interval [a, b) is the interval between a and b including a and not including b.",
      "examples": [
        "Input: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]",
        "Output: 0",
        "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]",
        "Output: 1"
      ],
      "constraints": [
        "1 <= n <= 100",
        "1 <= meetings.length <= 105",
        "meetings[i].length == 2",
        "0 <= starti < endi <= 5 * 105",
        "All the values of starti are unique."
      ]
    },
    {
      "task_id": "friends-of-appropriate-ages",
      "problem_description": "There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person. A Person x will not send a friend request to a person y (x != y) if any of the following conditions is true: age[y] <= 0.5 * age[x] + 7, age[y] > age[x], age[y] > 100 && age[x] < 100. Otherwise, x will send a friend request to y. Note that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself. Return the total number of friend requests made.",
      "examples": [
        "Input: ages = [16,16]\nOutput: 2\nExplanation: 2 people friend request each other.",
        "Input: ages = [16,17,18]\nOutput: 2\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.",
        "Input: ages = [20,30,100,110,120]\nOutput: 3\nExplanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100."
      ],
      "constraints": [
        "n == ages.length",
        "1 <= n <= 2 * 10^4",
        "1 <= ages[i] <= 120"
      ]
    },
    {
      "task_id": "merge-strings-alternately",
      "problem_description": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.",
      "examples": [
        "Input: word1 = \"abc\", word2 = \"pqr\"\nOutput: \"apbqcr\"",
        "Input: word1 = \"ab\", word2 = \"pqrs\"\nOutput: \"apbqrs\"",
        "Input: word1 = \"abcd\", word2 = \"pq\"\nOutput: \"apbqcd\""
      ],
      "constraints": [
        "1 <= word1.length, word2.length <= 100",
        "word1 and word2 consist of lowercase English letters."
      ]
    },
    {
      "task_id": "minimize-maximum-pair-sum-in-array",
      "problem_description": "Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that each element of nums is in exactly one pair, and the maximum pair sum is minimized. Return the minimized maximum pair sum after optimally pairing up the elements.",
      "examples": [
        "Input: nums = [3,5,2,3]\nOutput: 7\nExplanation: The elements can be paired up into pairs (3,3) and (5,2). The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.",
        "Input: nums = [3,5,4,2,4,6]\nOutput: 8\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2). The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8."
      ],
      "constraints": [
        "n == nums.length",
        "2 <= n <= 105",
        "n is even.",
        "1 <= nums[i] <= 105"
      ]
    },
    {
      "task_id": "make-string-a-subsequence-using-cyclic-increments",
      "problem_description": "You are given two 0-indexed strings str1 and str2. In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'. Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise. Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.",
      "examples": [
        "Input: str1 = \"abc\", str2 = \"ad\"\nOutput: true",
        "Input: str1 = \"zc\", str2 = \"ad\"\nOutput: true",
        "Input: str1 = \"ab\", str2 = \"d\"\nOutput: false"
      ],
      "constraints": [
        "1 <= str1.length <= 105",
        "1 <= str2.length <= 105",
        "str1 and str2 consist of only lowercase English letters."
      ]
    },
    {
      "task_id": "number-of-subsequences-that-satisfy-the-given-sum-condition",
      "problem_description": "You are given an array of integers nums and an integer target. Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target.",
      "examples": [
        "Input: nums = [3,5,6,7], target = 9\nOutput: 4",
        "Input: nums = [3,3,6,8], target = 10\nOutput: 6",
        "Input: nums = [2,3,3,4,6,7], target = 12\nOutput: 61"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 106",
        "1 <= target <= 106"
      ]
    },
    {
      "task_id": "flower-planting-with-no-adjacent",
      "problem_description": "You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers. All gardens have at most 3 paths coming into or leaving it. Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers. It is guaranteed an answer exists.",
      "examples": [
        "Input: n = 3, paths = [[1,2],[2,3],[3,1]]\nOutput: [1,2,3]",
        "Input: n = 4, paths = [[1,2],[3,4]]\nOutput: [1,2,1,2]",
        "Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\nOutput: [1,2,3,4]"
      ],
      "constraints": [
        "1 <= n <= 104",
        "0 <= paths.length <= 2 * 104",
        "paths[i].length == 2",
        "1 <= xi, yi <= n",
        "xi != yi",
        "Every garden has at most 3 paths coming into or leaving it."
      ]
    },
    {
      "task_id": "binary-tree-vertical-order-traversal",
      "problem_description": "Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right.",
      "examples": [
        "Input: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]",
        "Input: root = [3,9,8,4,0,1,7]\nOutput: [[4],[9],[3,0,1],[8],[7]]",
        "Input: root = [1,2,3,4,10,9,11,null,5,null,null,null,null,null,null,null,6]\nOutput: [[4],[2,5],[1,10,9,6],[3],[11]]"
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [0, 100].",
        "-100 <= Node.val <= 100"
      ]
    },
    {
      "task_id": "brace-expansion",
      "problem_description": "You are given a string s representing a list of words. Each letter in the word has one or more options. If there is one option, the letter is represented as is. If there is more than one option, then curly braces delimit the options. For example, \"{a,b,c}\" represents options [\"a\", \"b\", \"c\"]. The original list is [\"ab\", \"ac\"]. Return all words that can be formed in this manner, sorted in lexicographical order.",
      "examples": [
        "Input: s = \"{a,b}c{d,e}f\"\nOutput: [\"acdf\",\"acef\",\"bcdf\",\"bcef\"]",
        "Input: s = \"abcd\"\nOutput: [\"abcd\"]"
      ],
      "constraints": [
        "1 <= s.length <= 50",
        "s consists of curly brackets '{}', commas ',', and lowercase English letters.",
        "s is guaranteed to be a valid input.",
        "There are no nested curly brackets.",
        "All characters inside a pair of consecutive opening and ending curly brackets are different."
      ]
    },
    {
      "task_id": "similar-string-groups",
      "problem_description": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X. Together, these form two connected groups by similarity: a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?",
      "examples": [
        "Input: strs = [\"tars\",\"rats\",\"arts\",\"star\"]\nOutput: 2",
        "Input: strs = [\"omv\",\"ovm\"]\nOutput: 1"
      ],
      "constraints": [
        "1 <= strs.length <= 300",
        "1 <= strs[i].length <= 300",
        "strs[i] consists of lowercase letters only.",
        "All words in strs have the same length and are anagrams of each other."
      ]
    },
    {
      "task_id": "water-and-jug-problem",
      "problem_description": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach target using the following operations: Fill either jug completely with water. Completely empty either jug. Pour water from one jug into another until the receiving jug is full, or the transferring jug is empty.",
      "examples": [
        "Input:   x = 3, y = 5, target = 4 \nOutput:   true",
        "Input:   x = 2, y = 6, target = 5 \nOutput:   false",
        "Input:   x = 1, y = 2, target = 3 \nOutput:   true"
      ],
      "constraints": [
        "1 <= x, y, target <= 103"
      ]
    },
    {
      "task_id": "web-crawler-multithreaded",
      "problem_description": "Given a URL startUrl and an interface HtmlParser, implement a Multi-threaded web crawler to crawl all links that are under the same hostname as startUrl. Return all URLs obtained by your web crawler in any order. Your crawler should: Start from the page: startUrl Call HtmlParser.getUrls(url) to get all URLs from a webpage of a given URL. Do not crawl the same link twice. Explore only the links that are under the same hostname as startUrl. The hostname is example.org. For simplicity's sake, you may assume all URLs use HTTP protocol without any port specified. The HtmlParser interface is defined as such: interface HtmlParser { public List getUrls(String url); } Note that getUrls(String url) simulates performing an HTTP request. You can treat it as a blocking function call that waits for an HTTP request to finish. It is guaranteed that getUrls(String url) will return the URLs within 15ms. Single-threaded solutions will exceed the time limit so, can your multi-threaded web crawler do better?",
      "examples": [
        "Input:\nurls = [\n  \"http://news.yahoo.com\",\n  \"http://news.yahoo.com/news\",\n  \"http://news.yahoo.com/news/topics/\",\n  \"http://news.google.com\",\n  \"http://news.yahoo.com/us\"\n]\nedges = [[2,0],[2,1],[3,2],[3,1],[0,4]]\nstartUrl = \"http://news.yahoo.com/news/topics/\"\nOutput: [\n  \"http://news.yahoo.com\",\n  \"http://news.yahoo.com/news\",\n  \"http://news.yahoo.com/news/topics/\",\n  \"http://news.yahoo.com/us\"\n]",
        "Input: \nurls = [\n  \"http://news.yahoo.com\",\n  \"http://news.yahoo.com/news\",\n  \"http://news.yahoo.com/news/topics/\",\n  \"http://news.google.com\"\n]\nedges = [[0,2],[2,1],[3,2],[3,1],[3,0]]\nstartUrl = \"http://news.google.com\"\nOutput: [\"http://news.google.com\"]"
      ],
      "constraints": [
        "1 <= urls.length <= 1000",
        "1 <= urls[i].length <= 300",
        "startUrl is one of the urls.",
        "Hostname label must be from 1 to 63 characters long, including the dots, may contain only the ASCII letters from 'a' to 'z', digits from '0' to '9' and the hyphen-minus character ('-').",
        "The hostname may not start or end with the hyphen-minus character ('-').",
        "You may assume there're no duplicates in the URL library."
      ]
    },
    {
      "task_id": "champagne-tower",
      "problem_description": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup of champagne. Then, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. A glass at the bottom row has its excess champagne fall on the floor. Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed).",
      "examples": [
        "Input: poured = 1, query_row = 1, query_glass = 1\nOutput: 0.00000",
        "Input: poured = 2, query_row = 1, query_glass = 1\nOutput: 0.50000",
        "Input: poured = 100000009, query_row = 33, query_glass = 17\nOutput: 1.00000"
      ],
      "constraints": [
        "0 <= poured <= 109",
        "0 <= query_glass <= query_row < 100"
      ]
    },
    {
      "task_id": "optimal-division",
      "problem_description": "You are given an integer array nums. The adjacent integers in nums will perform the float division. However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such that the value of the expression after the evaluation is maximum. Return the corresponding expression that has the maximum value in string format. Note: your expression should not contain redundant parenthesis.",
      "examples": [
        "Input: nums = [1000,100,10,2]\nOutput: \"1000/(100/10/2)\"",
        "Input: nums = [2,3,4]\nOutput: \"2/(3/4)\""
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "2 <= nums[i] <= 1000",
        "There is only one optimal division for the given input."
      ]
    },
    {
      "task_id": "tallest-billboard",
      "problem_description": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.",
      "examples": [
        "Input: rods = [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.",
        "Input: rods = [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.",
        "Input: rods = [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0."
      ],
      "constraints": [
        "1 <= rods.length <= 20",
        "1 <= rods[i] <= 1000",
        "sum(rods[i]) <= 5000"
      ]
    },
    {
      "task_id": "maximum-sum-circular-subarray",
      "problem_description": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.",
      "examples": [
        "Input: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.",
        "Input: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.",
        "Input: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2."
      ],
      "constraints": [
        "n == nums.length",
        "1 <= n <= 3 * 104",
        "-3 * 104 <= nums[i] <= 3 * 104"
      ]
    },
    {
      "task_id": "find-maximum-non-decreasing-array-length",
      "problem_description": "You are given a 0-indexed integer array nums. You can perform any number of operations, where each operation involves selecting a subarray of the array and replacing it with the sum of its elements. A subarray is a contiguous non-empty sequence of elements within an array. Return the maximum length of a non-decreasing array that can be made after applying operations.",
      "examples": [
        "Input: nums = [5,2,2]\nOutput: 1",
        "Input: nums = [1,2,3,4]\nOutput: 4",
        "Input: nums = [4,3,2,6]\nOutput: 3"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 105"
      ]
    },
    {
      "task_id": "first-bad-version",
      "problem_description": "You are given n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
      "examples": [
        "Input: n = 5, bad = 4\nOutput: 4\nExplanation:\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.",
        "Input: n = 1, bad = 1\nOutput: 1"
      ],
      "constraints": [
        "1 <= bad <= n <= 231 - 1"
      ]
    },
    {
      "task_id": "number-of-unique-categories",
      "problem_description": "You are given an integer n and an object categoryHandler of class CategoryHandler. There are n elements, numbered from 0 to n - 1. Each element has a category, and your task is to find the number of unique categories. The class CategoryHandler contains the following function, which may help you: boolean haveSameCategory(integer a, integer b): Returns true if a and b are in the same category and false otherwise. Also, if either a or b is not a valid number (i.e. it's greater than or equal to nor less than 0), it returns false. Return the number of unique categories.",
      "examples": [
        "Input: n = 6, categoryHandler = [1,1,2,2,3,3]\nOutput: 3",
        "Input: n = 5, categoryHandler = [1,2,3,4,5]\nOutput: 5",
        "Input: n = 3, categoryHandler = [1,1,1]\nOutput: 1"
      ],
      "constraints": [
        "1 <= n <= 100"
      ]
    },
    {
      "task_id": "interval-list-intersections",
      "problem_description": "You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval.",
      "examples": [
        "Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\nOutput: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]",
        "Input: firstList = [[1,3],[5,9]], secondList = []\nOutput: []"
      ],
      "constraints": [
        "0 <= firstList.length, secondList.length <= 1000",
        "firstList.length + secondList.length >= 1",
        "0 <= starti < endi <= 109",
        "endi < starti+1",
        "0 <= startj < endj <= 109",
        "endj < startj+1"
      ]
    },
    {
      "task_id": "minimum-interval-to-include-each-query",
      "problem_description": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1. You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1. Return an array containing the answers to the queries.",
      "examples": [
        "Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\nOutput: [3,3,1,4]",
        "Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\nOutput: [2,-1,4,6]"
      ],
      "constraints": [
        "1 <= intervals.length <= 105",
        "1 <= queries.length <= 105",
        "intervals[i].length == 2",
        "1 <= lefti <= righti <= 107",
        "1 <= queries[j] <= 107"
      ]
    },
    {
      "task_id": "rectangle-area-ii",
      "problem_description": "You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner. Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once. Return the total area. Since the answer may be too large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\nOutput: 6",
        "Input: rectangles = [[0,0,1000000000,1000000000]]\nOutput: 49"
      ],
      "constraints": [
        "1 <= rectangles.length <= 200",
        "rectangles[i].length == 4",
        "0 <= xi1, yi1, xi2, yi2 <= 10^9",
        "xi1 <= xi2",
        "yi1 <= yi2",
        "All rectangles have non zero area."
      ]
    },
    {
      "task_id": "the-skyline-problem",
      "problem_description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]: lefti is the x coordinate of the left edge of the ith building. righti is the x coordinate of the right edge of the ith building. heighti is the height of the ith building. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note: There must be no consecutive horizontal lines of equal height in the output skyline.",
      "examples": [
        "Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]",
        "Input: buildings = [[0,2,3],[2,5,3]] Output: [[0,3],[5,0]]"
      ],
      "constraints": [
        "1 <= buildings.length <= 104",
        "0 <= lefti < righti <= 231 - 1",
        "1 <= heighti <= 231 - 1",
        "buildings is sorted by lefti in non-decreasing order."
      ]
    },
    {
      "task_id": "perfect-rectangle",
      "problem_description": "Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi). Return true if all the rectangles together form an exact cover of a rectangular region.",
      "examples": [
        "Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\nOutput: true",
        "Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\nOutput: false",
        "Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\nOutput: false"
      ],
      "constraints": [
        "1 <= rectangles.length <= 2 * 104",
        "rectangles[i].length == 4",
        "-105 <= xi < ai <= 105",
        "-105 <= yi < bi <= 105"
      ]
    },
    {
      "task_id": "construct-string-with-minimum-cost",
      "problem_description": "You are given a string target, an array of strings words, and an integer array costs, both arrays of the same length. Imagine an empty string s. You can perform the following operation any number of times (including zero): Choose an index i in the range [0, words.length - 1]. Append words[i] to s. The cost of operation is costs[i]. Return the minimum cost to make s equal to target. If it's not possible, return -1.",
      "examples": [
        "Input: target = \"abcdef\", words = [\"abdef\",\"abc\",\"d\",\"def\",\"ef\"], costs = [100,1,1,10,5]\nOutput: 7",
        "Input: target = \"aaaa\", words = [\"z\",\"zz\",\"zzz\"], costs = [1,10,100]\nOutput: -1"
      ],
      "constraints": [
        "1 <= target.length <= 5 * 104",
        "1 <= words.length == costs.length <= 5 * 104",
        "1 <= words[i].length <= target.length",
        "The total sum of words[i].length is less than or equal to 5 * 104.",
        "target and words[i] consist only of lowercase English letters.",
        "1 <= costs[i] <= 104"
      ]
    },
    {
      "task_id": "longest-repeating-substring",
      "problem_description": "Given a string s, return the length of the longest repeating substrings. If no repeating substring exists, return 0.",
      "examples": [
        "Input: s = \"abcd\"\nOutput: 0\nExplanation: There is no repeating substring.",
        "Input: s = \"abbaba\"\nOutput: 2\nExplanation: The longest repeating substrings are \"ab\" and \"ba\", each of which occurs twice.",
        "Input: s = \"aabcaabdaab\"\nOutput: 3\nExplanation: The longest repeating substring is \"aab\", which occurs 3 times."
      ],
      "constraints": [
        "1 <= s.length <= 2000",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "number-of-ways-to-separate-numbers",
      "problem_description": "You wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to separate the different numbers. You remember that the list of integers was non-decreasing and that no integer had leading zeros. Return the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: num = \"327\"\nOutput: 2\nExplanation: You could have written down the numbers:\n3, 27\n327",
        "Input: num = \"094\"\nOutput: 0\nExplanation: No numbers can have leading zeros and all numbers must be positive.",
        "Input: num = \"0\"\nOutput: 0\nExplanation: No numbers can have leading zeros and all numbers must be positive."
      ],
      "constraints": [
        "1 <= num.length <= 3500",
        "num consists of digits '0' through '9'."
      ]
    },
    {
      "task_id": "sum-of-scores-of-built-strings",
      "problem_description": "You are building a string s of length n one character at a time, prepending each new character to the front of the string. The score of si is the length of the longest common prefix between si and sn. Given the final string s, return the sum of the score of every si.",
      "examples": [
        "Input: s = \"babab\"\nOutput: 9\nExplanation:\nFor s1 == \"b\", the longest common prefix is \"b\" which has a score of 1.\nFor s2 == \"ab\", there is no common prefix so the score is 0.\nFor s3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3.\nFor s4 == \"abab\", there is no common prefix so the score is 0.\nFor s5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5.\nThe sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.",
        "Input: s = \"azbazbzaz\"\nOutput: 14\nExplanation:\nFor s2 == \"az\", the longest common prefix is \"az\" which has a score of 2.\nFor s6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3.\nFor s9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9.\nFor all other si, the score is 0.\nThe sum of the scores is 2 + 3 + 9 = 14, so we return 14."
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "longest-duplicate-substring",
      "problem_description": "Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times. The occurrences may overlap. Return any duplicated substring that has the longest possible length. If s does not have a duplicated substring, the answer is \"\".",
      "examples": [
        "Input: s = \"banana\"\nOutput: \"ana\"",
        "Input: s = \"abcd\"\nOutput: \"\""
      ],
      "constraints": [
        "2 <= s.length <= 3 * 104",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "maximum-gap",
      "problem_description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.",
      "examples": [
        "Input: nums = [3,6,9,1]\nOutput: 3",
        "Input: nums = [10]\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 109"
      ]
    },
    {
      "task_id": "sort-characters-by-frequency",
      "problem_description": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.",
      "examples": [
        "Input: s = \"tree\"\nOutput: \"eert\"",
        "Input: s = \"cccaaa\"\nOutput: \"aaaccc\"",
        "Input: s = \"Aabb\"\nOutput: \"bbAa\""
      ],
      "constraints": [
        "1 <= s.length <= 5 * 10^5",
        "s consists of uppercase and lowercase English letters and digits."
      ]
    },
    {
      "task_id": "top-k-frequent-words",
      "problem_description": "Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.",
      "examples": [
        "Input: words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\nOutput: [\"i\",\"love\"]",
        "Input: words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\nOutput: [\"the\",\"is\",\"sunny\",\"day\"]"
      ],
      "constraints": [
        "1 <= words.length <= 500",
        "1 <= words[i].length <= 10",
        "words[i] consists of lowercase English letters.",
        "k is in the range [1, The number of unique words[i]]"
      ]
    },
    {
      "task_id": "contains-duplicate-iii",
      "problem_description": "You are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that: i != j, abs(i - j) <= indexDiff. abs(nums[i] - nums[j]) <= valueDiff, and Return true if such pair exists or false otherwise.",
      "examples": [
        "Input: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true",
        "Input: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false"
      ],
      "constraints": [
        "2 <= nums.length <= 105",
        "-109 <= nums[i] <= 109",
        "1 <= indexDiff <= nums.length",
        "0 <= valueDiff <= 109"
      ]
    },
    {
      "task_id": "sort-an-array",
      "problem_description": "Given an array of integers nums, sort the array in ascending order and return it. You must solve the problem without using any built-in functions.",
      "examples": [
        "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]",
        "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]"
      ],
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "-5 * 104 <= nums[i] <= 5 * 104"
      ]
    },
    {
      "task_id": "count-subarrays-with-more-ones-than-zeros",
      "problem_description": "You are given a binary array nums containing only the integers 0 and 1. Return the number of subarrays in nums that have more 1's than 0's. A subarray is a contiguous sequence of elements within an array.",
      "examples": [
        "Input: nums = [0,1,1,0,1]\nOutput: 9",
        "Input: nums = [0]\nOutput: 0",
        "Input: nums = [1]\nOutput: 1"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] <= 1"
      ]
    },
    {
      "task_id": "merge-k-sorted-lists",
      "problem_description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
      "examples": [
        "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
        "Input: lists = []\nOutput: []",
        "Input: lists = [[]]\nOutput: []"
      ],
      "constraints": [
        "k == lists.length",
        "0 <= k <= 104",
        "0 <= lists[i].length <= 500",
        "-104 <= lists[i][j] <= 104",
        "lists[i] is sorted in ascending order.",
        "The sum of lists[i].length will not exceed 104."
      ]
    },
    {
      "task_id": "sort-list",
      "problem_description": "Given the head of a linked list, return the list after sorting it in ascending order.",
      "examples": [
        "Input: head = [4,2,1,3]\nOutput: [1,2,3,4]",
        "Input: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
        "Input: head = []\nOutput: []"
      ],
      "constraints": [
        "The number of nodes in the list is in the range [0, 5 * 104].",
        "-105 <= Node.val <= 105"
      ]
    },
    {
      "task_id": "count-of-range-sum",
      "problem_description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.",
      "examples": [
        "Input: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
        "Input: nums = [0], lower = 0, upper = 0\nOutput: 1"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-231 <= nums[i] <= 231 - 1",
        "-105 <= lower <= upper <= 105",
        "The answer is guaranteed to fit in a 32-bit integer."
      ]
    },
    {
      "task_id": "find-the-index-of-permutation",
      "problem_description": "Given an array perm of length n which is a permutation of [1, 2, ..., n], return the index of perm in the lexicographically sorted array of all of the permutations of [1, 2, ..., n]. Since the answer may be very large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: perm = [1,2]\nOutput: 0\n",
        "Input: perm = [3,1,2]\nOutput: 4\n"
      ],
      "constraints": [
        "1 <= n == perm.length <= 10^5",
        "perm is a permutation of [1, 2, ..., n]."
      ]
    },
    {
      "task_id": "maximum-strictly-increasing-cells-in-a-matrix",
      "problem_description": "Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell. From the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves. Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell. Return an integer denoting the maximum number of cells that can be visited.",
      "examples": [
        "Input: mat = [[3,1],[3,4]]\nOutput: 2\nExplanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2.",
        "Input: mat = [[1,1],[1,1]]\nOutput: 1\nExplanation: Since the cells must be strictly increasing, we can only visit one cell in this example.",
        "Input: mat = [[3,1,6],[-9,5,7]]\nOutput: 4\nExplanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4."
      ],
      "constraints": [
        "m == mat.length",
        "n == mat[i].length",
        "1 <= m, n <= 105",
        "1 <= m * n <= 105",
        "-105 <= mat[i][j] <= 105"
      ]
    },
    {
      "task_id": "k-empty-slots",
      "problem_description": "You have n bulbs in a row numbered from 1 to n. Initially, all the bulbs are turned off. We turn on exactly one bulb every day until all bulbs are on after n days. You are given an array bulbs of length n where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x where i is 0-indexed and x is 1-indexed. Given an integer k, return the minimum day number such that there exists two turned on bulbs that have exactly k bulbs between them that are all turned off. If there isn't such day, return -1.",
      "examples": [
        "Input: bulbs = [1,3,2], k = 1\nOutput: 2",
        "Input: bulbs = [1,2,3], k = 1\nOutput: -1"
      ],
      "constraints": [
        "n == bulbs.length",
        "1 <= n <= 2 * 10^4",
        "1 <= bulbs[i] <= n",
        "bulbs is a permutation of numbers from 1 to n.",
        "0 <= k <= 2 * 10^4"
      ]
    },
    {
      "task_id": "the-skyline-problem",
      "problem_description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively. The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]: lefti is the x coordinate of the left edge of the ith building. righti is the x coordinate of the right edge of the ith building. heighti is the height of the ith building. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour. Note: There must be no consecutive horizontal lines of equal height in the output skyline.",
      "examples": [
        "Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]",
        "Input: buildings = [[0,2,3],[2,5,3]] Output: [[0,3],[5,0]]"
      ],
      "constraints": [
        "1 <= buildings.length <= 104",
        "0 <= lefti < righti <= 231 - 1",
        "1 <= heighti <= 231 - 1",
        "buildings is sorted by lefti in non-decreasing order."
      ]
    },
    {
      "task_id": "count-the-number-of-k-big-indices",
      "problem_description": "You are given a 0-indexed integer array nums and a positive integer k. We call an index i k-big if the following conditions are satisfied: There exist at least k different indices idx1 such that idx1 < i and nums[idx1] < nums[i]. There exist at least k different indices idx2 such that idx2 > i and nums[idx2] < nums[i]. Return the number of k-big indices.",
      "examples": [
        "Input: nums = [2,3,6,5,2,3], k = 2\nOutput: 2",
        "Input: nums = [1,1,1], k = 3\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i], k <= nums.length"
      ]
    },
    {
      "task_id": "contains-duplicate-iii",
      "problem_description": "You are given an integer array nums and two integers indexDiff and valueDiff. Find a pair of indices (i, j) such that: i != j, abs(i - j) <= indexDiff. abs(nums[i] - nums[j]) <= valueDiff, and Return true if such pair exists or false otherwise.",
      "examples": [
        "Input: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true",
        "Input: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false"
      ],
      "constraints": [
        "2 <= nums.length <= 105",
        "-109 <= nums[i] <= 109",
        "1 <= indexDiff <= nums.length",
        "0 <= valueDiff <= 109"
      ]
    },
    {
      "task_id": "critical-connections-in-a-network",
      "problem_description": "There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order.",
      "examples": [
        "Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] Output: [[1,3]]",
        "Input: n = 2, connections = [[0,1]] Output: [[0,1]]"
      ],
      "constraints": [
        "2 <= n <= 105",
        "n - 1 <= connections.length <= 105",
        "0 <= ai, bi <= n - 1",
        "ai != bi",
        "There are no repeated connections."
      ]
    },
    {
      "task_id": "minimum-number-of-days-to-disconnect-island",
      "problem_description": "You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's. The grid is said to be connected if we have exactly one island, otherwise is said disconnected. In one day, we are allowed to change any single land cell (1) into a water cell (0). Return the minimum number of days to disconnect the grid.",
      "examples": [
        "Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n\nOutput: 2",
        "Input: grid = [[1,1]]\nOutput: 2"
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 30",
        "grid[i][j] is either 0 or 1."
      ]
    },
    {
      "task_id": "minimum-edge-weight-equilibrium-queries-in-a-tree",
      "problem_description": "There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ui, vi, wi] indicates that there is an edge between nodes ui and vi with weight wi in the tree. You are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, find the minimum number of operations required to make the weight of every edge on the path from ai to bi equal. In one operation, you can choose any edge of the tree and change its weight to any value. Note that: Queries are independent of each other, meaning that the tree returns to its initial state on each new query. The path from ai to bi is a sequence of distinct nodes starting with node ai and ending with node bi such that every two adjacent nodes in the sequence share an edge in the tree. Return an array answer of length m where answer[i] is the answer to the ith query.",
      "examples": [
        "Input: n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]\nOutput: [0,0,1,3]",
        "Input: n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]\nOutput: [1,2,2,3]"
      ],
      "constraints": [
        "1 <= n <= 104",
        "edges.length == n - 1",
        "edges[i].length == 3",
        "0 <= ui, vi < n",
        "1 <= wi <= 26",
        "The input is generated such that edges represents a valid tree.",
        "1 <= queries.length == m <= 2 * 104",
        "queries[i].length == 2",
        "0 <= ai, bi < n"
      ]
    },
    {
      "task_id": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
      "problem_description": "Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight. Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order.",
      "examples": [
        "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] Output: [[0,1],[2,3,4,5]]",
        "Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] Output: [[],[0,1,2,3]]"
      ],
      "constraints": [
        "2 <= n <= 100",
        "1 <= edges.length <= min(200, n * (n - 1) / 2)",
        "edges[i].length == 3",
        "0 <= ai < bi < n",
        "1 <= weighti <= 1000",
        "All pairs (ai, bi) are distinct."
      ]
    },
    {
      "task_id": "maximum-xor-product",
      "problem_description": "Given three integers a, b, and n, return the maximum value of (a XOR x) * (b XOR x) where 0 <= x < 2n. Note that XOR is the bitwise XOR operation.",
      "examples": [
        "Input: a = 12, b = 5, n = 4\nOutput: 98",
        "Input: a = 6, b = 7 , n = 5\nOutput: 930",
        "Input: a = 1, b = 6, n = 3\nOutput: 12"
      ],
      "constraints": [
        "0 <= a, b < 250",
        "0 <= n <= 50"
      ]
    },
    {
      "task_id": "transform-to-chessboard",
      "problem_description": "You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other. Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1. A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent.",
      "examples": [
        "Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\nOutput: 2",
        "Input: board = [[0,1],[1,0]]\nOutput: 0",
        "Input: board = [[1,0],[1,0]]\nOutput: -1"
      ],
      "constraints": [
        "n == board.length",
        "n == board[i].length",
        "2 <= n <= 30",
        "board[i][j] is either 0 or 1."
      ]
    },
    {
      "task_id": "maximum-number-of-groups-getting-fresh-donuts",
      "problem_description": "There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. Each customer will get exactly one donut. When a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group. You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.",
      "examples": [
        "Input: batchSize = 3, groups = [1,2,3,4,5,6]\nOutput: 4",
        "Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]\nOutput: 4"
      ],
      "constraints": [
        "1 <= batchSize <= 9",
        "1 <= groups.length <= 30",
        "1 <= groups[i] <= 109"
      ]
    },
    {
      "task_id": "maximum-strong-pair-xor-i",
      "problem_description": "You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition: |x - y| <= min(x, y). You need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array. Return the maximum XOR value out of all possible strong pairs in the array nums. Note that you can pick the same integer twice to form a pair.",
      "examples": [
        "Input: nums = [1,2,3,4,5]\nOutput: 7",
        "Input: nums = [10,100]\nOutput: 0",
        "Input: nums = [5,6,25,30]\nOutput: 7"
      ],
      "constraints": [
        "1 <= nums.length <= 50",
        "1 <= nums[i] <= 100"
      ]
    },
    {
      "task_id": "minimum-cost-to-connect-two-groups-of-points",
      "problem_description": "You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2. The cost of the connection between any two points are given in an size1 x size2 matrix where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. The groups are connected if each point in both groups is connected to one or more points in the opposite group. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group. Return the minimum cost it takes to connect the two groups.",
      "examples": [
        "Input: cost = [[15, 96], [36, 2]]\nOutput: 17",
        "Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\nOutput: 4",
        "Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\nOutput: 10"
      ],
      "constraints": [
        "size1 == cost.length",
        "size2 == cost[i].length",
        "1 <= size1, size2 <= 12",
        "size1 >= size2",
        "0 <= cost[i][j] <= 100"
      ]
    },
    {
      "task_id": "distribute-candies-among-children-i",
      "problem_description": "You are given two positive integers n and limit. Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.",
      "examples": [
        "Input: n = 5, limit = 2\nOutput: 3\nExplanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).",
        "Input: n = 3, limit = 3\nOutput: 10\nExplanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0)."
      ],
      "constraints": [
        "1 <= n <= 50",
        "1 <= limit <= 50"
      ]
    },
    {
      "task_id": "coordinate-with-maximum-network-quality",
      "problem_description": "You are given an array of network towers towers, where towers[i] = [xi, yi, qi] denotes the ith network tower with location (xi, yi) and quality factor qi. All the coordinates are integral coordinates on the X-Y plane, and the distance between the two coordinates is the Euclidean distance. You are also given an integer radius where a tower is reachable if the distance is less than or equal to radius. Outside that distance, the signal becomes garbled, and the tower is not reachable. The signal quality of the ith tower at a coordinate (x, y) is calculated with the formula \u230aqi / (1 + d)\u230b, where d is the distance between the tower and the coordinate. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers. Return the array [cx, cy] representing the integral coordinate (cx, cy) where the network quality is maximum. If there are multiple coordinates with the same network quality, return the lexicographically minimum non-negative coordinate. A coordinate (x1, y1) is lexicographically smaller than (x2, y2) if either: x1 < x2, or x1 == x2 and y1 < y2.",
      "examples": [
        "Input: towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\nOutput: [2,1]",
        "Input: towers = [[23,11,21]], radius = 9\nOutput: [23,11]",
        "Input: towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\nOutput: [1,2]"
      ],
      "constraints": [
        "1 <= towers.length <= 50",
        "towers[i].length == 3",
        "0 <= xi, yi, qi <= 50",
        "1 <= radius <= 50"
      ]
    },
    {
      "task_id": "collecting-chocolates",
      "problem_description": "You are given a 0-indexed integer array nums of size n representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index i is nums[i]. Each chocolate is of a different type, and initially, the chocolate at the index i is of ith type. In one operation, you can do the following with an incurred cost of x: Simultaneously change the chocolate of ith type to ((i + 1) mod n)th type for all chocolates. Return the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.",
      "examples": [
        "Input: nums = [20,1,15], x = 5\nOutput: 13",
        "Input: nums = [1,2,3], x = 4\nOutput: 6"
      ],
      "constraints": [
        "1 <= nums.length <= 1000",
        "1 <= nums[i] <= 10^9",
        "1 <= x <= 10^9"
      ]
    },
    {
      "task_id": "minimum-operations-to-maximize-last-elements-in-arrays",
      "problem_description": "You are given two 0-indexed integer arrays, nums1 and nums2, both having length n. You are allowed to perform a series of operations (possibly none). In an operation, you select an index i in the range [0, n - 1] and swap the values of nums1[i] and nums2[i]. Your task is to find the minimum number of operations required to satisfy the following conditions: nums1[n - 1] is equal to the maximum value among all elements of nums1, i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]). nums2[n - 1] is equal to the maximum value among all elements of nums2, i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]). Return an integer denoting the minimum number of operations needed to meet both conditions, or -1 if it is impossible to satisfy both conditions.",
      "examples": [
        "Input: nums1 = [1,2,7], nums2 = [4,5,3]\nOutput: 1",
        "Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]\nOutput: 2",
        "Input: nums1 = [1,5,4], nums2 = [2,5,3]\nOutput: -1"
      ],
      "constraints": [
        "1 <= n == nums1.length == nums2.length <= 1000",
        "1 <= nums1[i] <= 10^9",
        "1 <= nums2[i] <= 10^9"
      ]
    },
    {
      "task_id": "count-substrings-that-differ-by-one-character",
      "problem_description": "Given two strings s and t, find the number of ways you can choose a non-empty substring of s and replace a single character by a different character such that the resulting substring is a substring of t. A substring is a contiguous sequence of characters within a string.",
      "examples": [
        "Input: s = \"aba\", t = \"baba\"\nOutput: 6",
        "Input: s = \"ab\", t = \"bb\"\nOutput: 3"
      ],
      "constraints": [
        "1 <= s.length, t.length <= 100",
        "s and t consist of lowercase English letters only."
      ]
    },
    {
      "task_id": "game-of-nim",
      "problem_description": "Alice and Bob take turns playing a game with Alice starting first. In this game, there are n piles of stones. On each player's turn, the player should remove any positive number of stones from a non-empty pile of his or her choice. The first player who cannot make a move loses, and the other player wins. Given an integer array piles, where piles[i] is the number of stones in the ith pile, return true if Alice wins, or false if Bob wins. Both Alice and Bob play optimally.",
      "examples": [
        "Input: piles = [1]\nOutput: true",
        "Input: piles = [1,1]\nOutput: false",
        "Input: piles = [1,2,3]\nOutput: false"
      ],
      "constraints": [
        "n == piles.length",
        "1 <= n <= 7",
        "1 <= piles[i] <= 7"
      ]
    },
    {
      "task_id": "divisor-game",
      "problem_description": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of: Choosing any x with 0 < x < n and n % x == 0. Replacing the number n on the chalkboard with n - x. Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally.",
      "examples": [
        "Input: n = 2\nOutput: true\nExplanation: Alice chooses 1, and Bob has no more moves.",
        "Input: n = 3\nOutput: false\nExplanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves."
      ],
      "constraints": [
        "1 <= n <= 1000"
      ]
    },
    {
      "task_id": "vowels-game-in-a-string",
      "problem_description": "Alice and Bob are playing a game on a string. You are given a string s, Alice and Bob will take turns playing the following game where Alice starts first: On Alice's turn, she has to remove any non-empty substring from s that contains an odd number of vowels. On Bob's turn, he has to remove any non-empty substring from s that contains an even number of vowels. The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play optimally. The English vowels are: a, e, i, o, and u.",
      "examples": [
        "Input: s = \"leetcoder\"\nOutput: true\nExplanation:\nAlice can win the game as follows:\n\nAlice plays first, she can delete the underlined substring in s = \"leetcoder\" which contains 3 vowels. The resulting string is s = \"der\".\nBob plays second, he can delete the underlined substring in s = \"der\" which contains 0 vowels. The resulting string is s = \"er\".\nAlice plays third, she can delete the whole string s = \"er\" which contains 1 vowel.\nBob plays fourth, since the string is empty, there is no valid play for Bob. So Alice wins the game.",
        "Input: s = \"bbcd\"\nOutput: false\nExplanation:\nThere is no valid play for Alice in her first turn, so Alice loses the game."
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "stone-game-vi",
      "problem_description": "Alice and Bob take turns playing a game, with Alice starting first. There are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently. You are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone. The winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally. Both players know the other's values. Determine the result of the game, and: If Alice wins, return 1. If Bob wins, return -1. If the game results in a draw, return 0.",
      "examples": [
        "Input: aliceValues = [1,3], bobValues = [2,1]\nOutput: 1",
        "Input: aliceValues = [1,2], bobValues = [3,1]\nOutput: 0",
        "Input: aliceValues = [2,4,3], bobValues = [1,6,7]\nOutput: -1"
      ],
      "constraints": [
        "n == aliceValues.length == bobValues.length",
        "1 <= n <= 105",
        "1 <= aliceValues[i], bobValues[i] <= 100"
      ]
    },
    {
      "task_id": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
      "problem_description": "There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece. Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first. Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'. Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'. Alice and Bob cannot remove pieces from the edge of the line. If a player cannot make a move on their turn, that player loses and the other player wins. Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.",
      "examples": [
        "Input: colors = \"AAABABB\"\nOutput: true",
        "Input: colors = \"AA\"\nOutput: false",
        "Input: colors = \"ABBBBBBBAAA\"\nOutput: false"
      ],
      "constraints": [
        "1 <= colors.length <= 105",
        "colors consists of only the letters 'A' and 'B'"
      ]
    },
    {
      "task_id": "maximum-palindromes-after-operations",
      "problem_description": "You are given a 0-indexed string array words having length n and containing 0-indexed strings. You are allowed to perform the following operation any number of times (including zero): Choose integers i, j, x, and y such that 0 <= i, j < n, 0 <= x < words[i].length, 0 <= y < words[j].length, and swap the characters words[i][x] and words[j][y]. Return an integer denoting the maximum number of palindromes words can contain, after performing some operations.",
      "examples": [
        "Input: words = [\"abbb\",\"ba\",\"aa\"]\nOutput: 3",
        "Input: words = [\"abc\",\"ab\"]\nOutput: 2",
        "Input: words = [\"cd\",\"ef\",\"a\"]\nOutput: 1"
      ],
      "constraints": [
        "1 <= words.length <= 1000",
        "1 <= words[i].length <= 100",
        "words[i] consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "minimum-operations-to-make-a-subsequence",
      "problem_description": "You are given an array target that consists of distinct integers and another integer array arr that can have duplicates. In one operation, you can insert any integer at any position in arr. Return the minimum number of operations needed to make target a subsequence of arr. A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.",
      "examples": [
        "Input: target = [5,1,3], arr = [9,4,2,3,4]\nOutput: 2\nExplanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.",
        "Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\nOutput: 3"
      ],
      "constraints": [
        "1 <= target.length, arr.length <= 105",
        "1 <= target[i], arr[i] <= 109",
        "target contains no duplicates."
      ]
    },
    {
      "task_id": "count-common-words-with-one-occurrence",
      "problem_description": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.",
      "examples": [
        "Input: words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\nOutput: 2",
        "Input: words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\nOutput: 0",
        "Input: words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\nOutput: 1"
      ],
      "constraints": [
        "1 <= words1.length, words2.length <= 1000",
        "1 <= words1[i].length, words2[j].length <= 30",
        "words1[i] and words2[j] consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "check-if-one-string-swap-can-make-strings-equal",
      "problem_description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
      "examples": [
        "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true",
        "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false",
        "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true"
      ],
      "constraints": [
        "1 <= s1.length, s2.length <= 100",
        "s1.length == s2.length",
        "s1 and s2 consist of only lowercase English letters."
      ]
    },
    {
      "task_id": "how-many-numbers-are-smaller-than-the-current-number",
      "problem_description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i]. Return the answer in an array.",
      "examples": [
        "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]",
        "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
        "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
      ],
      "constraints": [
        "2 <= nums.length <= 500",
        "0 <= nums[i] <= 100"
      ]
    },
    {
      "task_id": "diagonal-traverse",
      "problem_description": "Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.",
      "examples": [
        "Input: mat = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,4,7,5,3,6,8,9]",
        "Input: mat = [[1,2],[3,4]]\nOutput: [1,2,3,4]"
      ],
      "constraints": [
        "m == mat.length",
        "n == mat[i].length",
        "1 <= m, n <= 104",
        "1 <= m * n <= 104",
        "-105 <= mat[i][j] <= 105"
      ]
    },
    {
      "task_id": "detect-cycles-in-2d-grid",
      "problem_description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid. A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell. Also, you cannot move to the cell that you visited in your last move. Return true if any cycle of the same value exists in grid, otherwise, return false.",
      "examples": [
        "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true",
        "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true",
        "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 500",
        "grid consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "find-valid-matrix-given-row-and-column-sums",
      "problem_description": "You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.",
      "examples": [
        "Input: rowSum = [3,8], colSum = [4,7]\nOutput: [[3,0],\n         [1,7]]",
        "Input: rowSum = [5,7,10], colSum = [8,6,8]\nOutput: [[0,5,0],\n         [6,1,0],\n         [2,0,8]]"
      ],
      "constraints": [
        "1 <= rowSum.length, colSum.length <= 500",
        "0 <= rowSum[i], colSum[i] <= 108",
        "sum(rowSum) == sum(colSum)"
      ]
    },
    {
      "task_id": "delete-greatest-value-in-each-row",
      "problem_description": "You are given an m x n matrix grid consisting of positive integers. Perform the following operation until grid becomes empty: Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer. Note that the number of columns decreases by one after each operation. Return the answer after performing the operations described above.",
      "examples": [
        "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8",
        "Input: grid = [[10]]\nOutput: 10"
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 50",
        "1 <= grid[i][j] <= 100"
      ]
    },
    {
      "task_id": "matrix-similarity-after-cyclic-shifts",
      "problem_description": "You are given an m x n integer matrix mat and an integer k. The matrix rows are 0-indexed. The following process happens k times: Even-indexed rows (0, 2, 4, ...) are cyclically shifted to the left. Odd-indexed rows (1, 3, 5, ...) are cyclically shifted to the right. Return true if the final modified matrix after k steps is identical to the original matrix, and false otherwise.",
      "examples": [
        "Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 4\nOutput: false\n",
        "Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2\nOutput: true\n",
        "Input: mat = [[2,2],[2,2]], k = 3\nOutput: true\n"
      ],
      "constraints": [
        "1 <= mat.length <= 25",
        "1 <= mat[i].length <= 25",
        "1 <= mat[i][j] <= 25",
        "1 <= k <= 50"
      ]
    },
    {
      "task_id": "maximize-the-confusion-of-an-exam",
      "problem_description": "A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer. You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may change the answer key for any question to 'T' or 'F'. Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.",
      "examples": [
        "Input: answerKey = \"TTFF\", k = 2\nOutput: 4",
        "Input: answerKey = \"TFFT\", k = 1\nOutput: 3",
        "Input: answerKey = \"TTFTTFTT\", k = 1\nOutput: 5"
      ],
      "constraints": [
        "n == answerKey.length",
        "1 <= n <= 5 * 10^4",
        "answerKey[i] is either 'T' or 'F'",
        "1 <= k <= n"
      ]
    },
    {
      "task_id": "shifting-letters-ii",
      "problem_description": "You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0. Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z'). Return the final string after all such shifts to s are applied.",
      "examples": [
        "Input: s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\nOutput: \"ace\"",
        "Input: s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\nOutput: \"catz\""
      ],
      "constraints": [
        "1 <= s.length, shifts.length <= 5 * 104",
        "shifts[i].length == 3",
        "0 <= starti <= endi < s.length",
        "0 <= directioni <= 1",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "substrings-that-begin-and-end-with-the-same-letter",
      "problem_description": "You are given a 0-indexed string s consisting of only lowercase English letters. Return the number of substrings in s that begin and end with the same character. A substring is a contiguous non-empty sequence of characters within a string.",
      "examples": [
        "Input: s = \"abcba\"\nOutput: 7",
        "Input: s = \"abacad\"\nOutput: 9",
        "Input: s = \"a\"\nOutput: 1"
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s consists only of lowercase English letters."
      ]
    },
    {
      "task_id": "subarray-product-less-than-k",
      "problem_description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.",
      "examples": [
        "Input: nums = [10,5,2,6], k = 100\nOutput: 8",
        "Input: nums = [1,2,3], k = 0\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 3 * 10^4",
        "1 <= nums[i] <= 1000",
        "0 <= k <= 10^6"
      ]
    },
    {
      "task_id": "minimize-maximum-of-array",
      "problem_description": "You are given a 0-indexed array nums comprising of n non-negative integers. In one operation, you must: Choose an integer i such that 1 <= i < n and nums[i] > 0. Decrease nums[i] by 1. Increase nums[i - 1] by 1. Return the minimum possible value of the maximum integer of nums after performing any number of operations.",
      "examples": [
        "Input: nums = [3,7,1,6]\nOutput: 5",
        "Input: nums = [10,1]\nOutput: 10"
      ],
      "constraints": [
        "n == nums.length",
        "2 <= n <= 105",
        "0 <= nums[i] <= 109"
      ]
    },
    {
      "task_id": "remove-sub-folders-from-the-filesystem",
      "problem_description": "Given a list of folders folder, return the folders after removing all sub-folders in those folders. If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a \"/\". The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.",
      "examples": [
        "Input: folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\nOutput: [\"/a\",\"/c/d\",\"/c/f\"]",
        "Input: folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\nOutput: [\"/a\"]",
        "Input: folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\nOutput: [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]"
      ],
      "constraints": [
        "1 <= folder.length <= 4 * 10^4",
        "2 <= folder[i].length <= 100",
        "folder[i] contains only lowercase letters and '/'.",
        "folder[i] always starts with the character '/'.",
        "Each folder name is unique."
      ]
    },
    {
      "task_id": "word-abbreviation",
      "problem_description": "Given an array of distinct strings words, return the minimal possible abbreviations for every word. The initial abbreviation for each word is: the first character, then the number of characters in between, followed by the last character. If more than one word shares the same abbreviation, then perform the following operation: Increase the prefix (characters in the first part) of each of their abbreviations by 1. This operation is repeated until every abbreviation is unique. At the end, if an abbreviation did not make a word shorter, then keep it as the original word.",
      "examples": [
        "Input: words = [\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"]\nOutput: [\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"]",
        "Input: words = [\"aa\",\"aaa\"]\nOutput: [\"aa\",\"aaa\"]"
      ],
      "constraints": [
        "1 <= words.length <= 400",
        "2 <= words[i].length <= 400",
        "words[i] consists of lowercase English letters.",
        "All the strings of words are unique."
      ]
    },
    {
      "task_id": "count-prefix-and-suffix-pairs-ii",
      "problem_description": "You are given a 0-indexed string array words. Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2: isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise. Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.",
      "examples": [
        "Input: words = [\"a\",\"aba\",\"ababa\",\"aa\"]\nOutput: 4",
        "Input: words = [\"pa\",\"papa\",\"ma\",\"mama\"]\nOutput: 2",
        "Input: words = [\"abab\",\"ab\"]\nOutput: 0"
      ],
      "constraints": [
        "1 <= words.length <= 105",
        "1 <= words[i].length <= 105",
        "words[i] consists only of lowercase English letters.",
        "The sum of the lengths of all words[i] does not exceed 5 * 105."
      ]
    },
    {
      "task_id": "k-th-smallest-in-lexicographical-order",
      "problem_description": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",
      "examples": [
        "Input: n = 13, k = 2\nOutput: 10",
        "Input: n = 1, k = 1\nOutput: 1"
      ],
      "constraints": [
        "1 <= k <= n <= 109"
      ]
    },
    {
      "task_id": "concatenated-words",
      "problem_description": "Given an array of strings words (without duplicates), return all the concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.",
      "examples": [
        "Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
        "Input: words = [\"cat\",\"dog\",\"catdog\"]\nOutput: [\"catdog\"]"
      ],
      "constraints": [
        "1 <= words.length <= 104",
        "1 <= words[i].length <= 30",
        "words[i] consists of only lowercase English letters.",
        "All the strings of words are unique.",
        "1 <= sum(words[i].length) <= 105"
      ]
    },
    {
      "task_id": "find-the-kth-largest-integer-in-the-array",
      "problem_description": "You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros. Return the string that represents the kth largest integer in nums. Note: Duplicate numbers should be counted distinctly.",
      "examples": [
        "Input: nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\nOutput: \"3\"",
        "Input: nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\nOutput: \"2\"",
        "Input: nums = [\"0\",\"0\"], k = 2\nOutput: \"0\""
      ],
      "constraints": [
        "1 <= k <= nums.length <= 104",
        "1 <= nums[i].length <= 100",
        "nums[i] consists of only digits.",
        "nums[i] will not have any leading zeros."
      ]
    },
    {
      "task_id": "maximum-subarray",
      "problem_description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
      "examples": [
        "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.",
        "Input: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.",
        "Input: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23."
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-104 <= nums[i] <= 104"
      ]
    },
    {
      "task_id": "maximum-sum-of-subsequence-with-non-adjacent-elements",
      "problem_description": "You are given an array nums consisting of integers. You are also given a 2D array queries, where queries[i] = [posi, xi]. For query i, we first set nums[posi] equal to xi, then we calculate the answer to query i which is the maximum sum of a subsequence of nums where no two adjacent elements are selected. Return the sum of the answers to all queries. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
      "examples": [
        "Input: nums = [3,5,9], queries = [[1,-2],[0,-3]]\nOutput: 21\nExplanation:\nAfter the 1st query, nums = [3,-2,9] and the maximum sum of a subsequence with non-adjacent elements is 3 + 9 = 12.\nAfter the 2nd query, nums = [-3,-2,9] and the maximum sum of a subsequence with non-adjacent elements is 9.",
        "Input: nums = [0,-1], queries = [[0,-5]]\nOutput: 0\nExplanation:\nAfter the 1st query, nums = [-5,-1] and the maximum sum of a subsequence with non-adjacent elements is 0 (choosing an empty subsequence)."
      ],
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "-105 <= nums[i] <= 105",
        "1 <= queries.length <= 5 * 104",
        "queries[i] == [posi, xi]",
        "0 <= posi <= nums.length - 1",
        "-105 <= xi <= 105"
      ]
    },
    {
      "task_id": "merge-k-sorted-lists",
      "problem_description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
      "examples": [
        "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
        "Input: lists = []\nOutput: []",
        "Input: lists = [[]]\nOutput: []"
      ],
      "constraints": [
        "k == lists.length",
        "0 <= k <= 104",
        "0 <= lists[i].length <= 500",
        "-104 <= lists[i][j] <= 104",
        "lists[i] is sorted in ascending order.",
        "The sum of lists[i].length will not exceed 104."
      ]
    },
    {
      "task_id": "beautiful-pairs",
      "problem_description": "You are given two 0-indexed integer arrays nums1 and nums2 of the same length. A pair of indices (i,j) is called beautiful if |nums1[i] - nums1[j]| + |nums2[i] - nums2[j]| is the smallest amongst all possible indices pairs where i < j. Return the beautiful pair. In the case that there are multiple beautiful pairs, return the lexicographically smallest pair. Note that |x| denotes the absolute value of x. A pair of indices (i1, j1) is lexicographically smaller than (i2, j2) if i1 < i2 or i1 == i2 and j1 < j2.",
      "examples": [
        "Input: nums1 = [1,2,3,2,4], nums2 = [2,3,1,2,3]\nOutput: [0,3]",
        "Input: nums1 = [1,2,4,3,2,5], nums2 = [1,4,2,3,5,1]\nOutput: [1,4]"
      ],
      "constraints": [
        "2 <= nums1.length, nums2.length <= 105",
        "nums1.length == nums2.length",
        "0 <= nums1i <= nums1.length",
        "0 <= nums2i <= nums2.length"
      ]
    },
    {
      "task_id": "shopping-offers",
      "problem_description": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy. You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer. Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.",
      "examples": [
        "Input: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\nOutput: 14",
        "Input: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\nOutput: 11"
      ],
      "constraints": [
        "n == price.length == needs.length",
        "1 <= n <= 6",
        "0 <= price[i], needs[i] <= 10",
        "1 <= special.length <= 100",
        "special[i].length == n + 1",
        "0 <= special[i][j] <= 50",
        "The input is generated that at least one of special[i][j] is non-zero for 0 <= j <= n - 1."
      ]
    },
    {
      "task_id": "the-score-of-students-solving-math-expression",
      "problem_description": "You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers. This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations: Compute multiplication, reading from left to right; Then, Compute addition, reading from left to right. You are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules: If an answer equals the correct answer of the expression, this student will be rewarded 5 points; Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded 2 points; Otherwise, this student will be rewarded 0 points. Return the sum of the points of the students.",
      "examples": [
        "Input: s = \"7+3*1*2\", answers = [20,13,42]\nOutput: 7",
        "Input: s = \"3+5*2\", answers = [13,0,10,13,13,16,16]\nOutput: 19",
        "Input: s = \"6+0*1\", answers = [12,9,6,4,8,6]\nOutput: 10"
      ],
      "constraints": [
        "3 <= s.length <= 31",
        "s represents a valid expression that contains only digits 0-9, '+', and '*' only.",
        "All the integer operands in the expression are in the inclusive range [0, 9].",
        "1 <= The count of all operators ('+' and '*') in the math expression <= 15",
        "Test data are generated such that the correct answer of the expression is in the range of [0, 1000].",
        "n == answers.length",
        "1 <= n <= 104",
        "0 <= answers[i] <= 1000"
      ]
    },
    {
      "task_id": "number-of-distinct-roll-sequences",
      "problem_description": "You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied: The greatest common divisor of any adjacent values in the sequence is equal to 1. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the ith roll is equal to the value of the jth roll, then abs(i - j) > 2. Return the total number of distinct sequences possible. Since the answer may be very large, return it modulo 10^9 + 7. Two sequences are considered distinct if at least one element is different.",
      "examples": [
        "Input: n = 4\nOutput: 184",
        "Input: n = 2\nOutput: 22"
      ],
      "constraints": [
        "1 <= n <= 104"
      ]
    },
    {
      "task_id": "remove-boxes",
      "problem_description": "You are given several boxes with different colors represented by different positive numbers. You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k >= 1), remove them and get k * k points. Return the maximum points you can get.",
      "examples": [
        "Input: boxes = [1,3,2,2,2,3,4,3,1]\nOutput: 23",
        "Input: boxes = [1,1,1]\nOutput: 9",
        "Input: boxes = [1]\nOutput: 1"
      ],
      "constraints": [
        "1 <= boxes.length <= 100",
        "1 <= boxes[i] <= 100"
      ]
    },
    {
      "task_id": "cat-and-mouse",
      "problem_description": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0. During each player's turn, they must travel along one edge of the graph that meets where they are. Additionally, it is not allowed for the Cat to travel to the Hole (node 0). The game can end in three ways: If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated, the game is a draw. Given a graph, and assuming both players play optimally, return 1 if the mouse wins the game, 2 if the cat wins the game, or 0 if the game is a draw.",
      "examples": [
        "Input: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0",
        "Input: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1"
      ],
      "constraints": [
        "3 <= graph.length <= 50",
        "1 <= graph[i].length < graph.length",
        "0 <= graph[i][j] < graph.length",
        "graph[i][j] != i",
        "graph[i] is unique.",
        "The mouse and the cat can always move."
      ]
    },
    {
      "task_id": "minimum-split-into-subarrays-with-gcd-greater-than-one",
      "problem_description": "You are given an array nums consisting of positive integers. Split the array into one or more disjoint subarrays such that: Each element of the array belongs to exactly one subarray, and The GCD of the elements of each subarray is strictly greater than 1. Return the minimum number of subarrays that can be obtained after the split. Note that: The GCD of a subarray is the largest positive integer that evenly divides all the elements of the subarray. A subarray is a contiguous part of the array.",
      "examples": [
        "Input: nums = [12,6,3,14,8]\nOutput: 2\nExplanation: We can split the array into the subarrays: [12,6,3] and [14,8].\n- The GCD of 12, 6 and 3 is 3, which is strictly greater than 1.\n- The GCD of 14 and 8 is 2, which is strictly greater than 1.\nIt can be shown that splitting the array into one subarray will make the GCD = 1.",
        "Input: nums = [4,12,6,14]\nOutput: 1\nExplanation: We can split the array into only one subarray, which is the whole array."
      ],
      "constraints": [
        "1 <= nums.length <= 2000",
        "2 <= nums[i] <= 10^9"
      ]
    },
    {
      "task_id": "count-array-pairs-divisible-by-k",
      "problem_description": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that: 0 <= i < j <= n - 1 and nums[i] * nums[j] is divisible by k.",
      "examples": [
        "Input: nums = [1,2,3,4,5], k = 2\nOutput: 7",
        "Input: nums = [1,2,3,4], k = 5\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i], k <= 105"
      ]
    },
    {
      "task_id": "most-frequent-prime",
      "problem_description": "You are given a m x n 0-indexed 2D matrix mat. From every cell, you can create numbers in the following way: There could be at most 8 paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east. Select a path from them and append digits in this path to the number being formed by traveling in this direction. Note that numbers are generated at every step, for example, if the digits along the path are 1, 9, 1, then there will be three numbers generated along the way: 1, 19, 191. Return the most frequent prime number greater than 10 out of all the numbers created by traversing the matrix or -1 if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the largest among them. It is invalid to change the direction during the move.",
      "examples": [
        "Input: mat = [[1,1],[9,9],[1,1]]\nOutput: 19",
        "Input: mat = [[7]]\nOutput: -1",
        "Input: mat = [[9,7,8],[4,6,5],[2,8,6]]\nOutput: 97"
      ],
      "constraints": [
        "m == mat.length",
        "n == mat[i].length",
        "1 <= m, n <= 6",
        "1 <= mat[i][j] <= 9"
      ]
    },
    {
      "task_id": "minimum-subarrays-in-a-valid-split",
      "problem_description": "You are given an integer array nums. Splitting of an integer array nums into subarrays is valid if the greatest common divisor of the first and last elements of each subarray is greater than 1, and each element of nums belongs to exactly one subarray. Return the minimum number of subarrays in a valid subarray splitting of nums. If a valid subarray splitting is not possible, return -1. Note that the greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers. A subarray is a contiguous non-empty part of an array.",
      "examples": [
        "Input: nums = [2,6,3,4,3]\nOutput: 2",
        "Input: nums = [3,5]\nOutput: 2",
        "Input: nums = [1,2,1]\nOutput: -1"
      ],
      "constraints": [
        "1 <= nums.length <= 1000",
        "1 <= nums[i] <= 105"
      ]
    },
    {
      "task_id": "smallest-value-after-replacing-with-sum-of-prime-factors",
      "problem_description": "You are given a positive integer n. Continuously replace n with the sum of its prime factors. Note that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n. Return the smallest value n will take on.",
      "examples": [
        "Input: n = 15\nOutput: 5\nExplanation: Initially, n = 15.\n15 = 3 * 5, so replace n with 3 + 5 = 8.\n8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.\n6 = 2 * 3, so replace n with 2 + 3 = 5.\n5 is the smallest value n will take on.",
        "Input: n = 3\nOutput: 3\nExplanation: Initially, n = 3.\n3 is the smallest value n will take on."
      ],
      "constraints": [
        "2 <= n <= 105"
      ]
    },
    {
      "task_id": "sum-of-prefix-scores-of-strings",
      "problem_description": "You are given an array words of size n consisting of non-empty strings. We define the score of a string term as the number of strings words[i] such that term is a prefix of words[i]. Return an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i]. Note that a string is considered as a prefix of itself.",
      "examples": [
        "Input: words = [\"abc\",\"ab\",\"bc\",\"b\"]\nOutput: [5,4,3,2]",
        "Input: words = [\"abcd\"]\nOutput: [4]"
      ],
      "constraints": [
        "1 <= words.length <= 1000",
        "1 <= words[i].length <= 1000",
        "words[i] consists of lowercase English letters."
      ]
    },
    {
      "task_id": "minimum-number-of-frogs-croaking",
      "problem_description": "You are given the string croakOfFrogs, which represents a combination of the string \"croak\" from different frogs, that is, multiple frogs can croak at the same time, so multiple \"croak\" are mixed. Return the minimum number of different frogs to finish all the croaks in the given string. A valid \"croak\" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid \"croak\" return -1.",
      "examples": [
        "Input: croakOfFrogs = \"croakcroak\"\nOutput: 1",
        "Input: croakOfFrogs = \"crcoakroak\"\nOutput: 2",
        "Input: croakOfFrogs = \"croakcrook\"\nOutput: -1"
      ],
      "constraints": [
        "1 <= croakOfFrogs.length <= 105",
        "croakOfFrogs is either 'c', 'r', 'o', 'a', or 'k'."
      ]
    },
    {
      "task_id": "minimum-operations-to-write-the-letter-y-on-a-grid",
      "problem_description": "You are given a 0-indexed n x n grid where n is odd, and grid[r][c] is 0, 1, or 2. We say that a cell belongs to the Letter Y if it belongs to one of the following: The diagonal starting at the top-left cell and ending at the center cell of the grid. The diagonal starting at the top-right cell and ending at the center cell of the grid. The vertical line starting at the center cell and ending at the bottom border of the grid. The Letter Y is written on the grid if and only if: All values at cells belonging to the Y are equal. All values at cells not belonging to the Y are equal. The values at cells belonging to the Y are different from the values at cells not belonging to the Y. Return the minimum number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to 0, 1, or 2.",
      "examples": [
        "Input: grid = [[1,2,2],[1,1,0],[0,1,0]]\nOutput: 3",
        "Input: grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\nOutput: 12"
      ],
      "constraints": [
        "3 <= n <= 49",
        "n == grid.length == grid[i].length",
        "0 <= grid[i][j] <= 2",
        "n is odd."
      ]
    },
    {
      "task_id": "letter-tile-possibilities",
      "problem_description": "You have n tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.",
      "examples": [
        "Input: tiles = \"AAB\"\nOutput: 8\nExplanation: The possible sequences are \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\".",
        "Input: tiles = \"AAABBC\"\nOutput: 188",
        "Input: tiles = \"V\"\nOutput: 1"
      ],
      "constraints": [
        "1 <= tiles.length <= 7",
        "tiles consists of uppercase English letters."
      ]
    },
    {
      "task_id": "most-frequent-number-following-key-in-an-array",
      "problem_description": "You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums. For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that: 0 <= i <= nums.length - 2, nums[i] == key and, nums[i + 1] == target. Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.",
      "examples": [
        "Input: nums = [1,100,200,1,100], key = 1\nOutput: 100",
        "Input: nums = [2,2,2,2,3], key = 2\nOutput: 2"
      ],
      "constraints": [
        "2 <= nums.length <= 1000",
        "1 <= nums[i] <= 1000",
        "The test cases will be generated such that the answer is unique."
      ]
    },
    {
      "task_id": "height-checker",
      "problem_description": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i].",
      "examples": [
        "Input: heights = [1,1,4,2,1,3]\nOutput: 3",
        "Input: heights = [5,1,2,3,4]\nOutput: 5",
        "Input: heights = [1,2,3,4,5]\nOutput: 0"
      ],
      "constraints": [
        "1 <= heights.length <= 100",
        "1 <= heights[i] <= 100"
      ]
    },
    {
      "task_id": "relative-sort-array",
      "problem_description": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.",
      "examples": [
        "Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]",
        "Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\nOutput: [22,28,8,6,17,44]"
      ],
      "constraints": [
        "1 <= arr1.length, arr2.length <= 1000",
        "0 <= arr1[i], arr2[i] <= 1000",
        "All the elements of arr2 are distinct.",
        "Each arr2[i] is in arr1."
      ]
    },
    {
      "task_id": "maximum-ice-cream-bars",
      "problem_description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. Note: The boy can buy the ice cream bars in any order. Return the maximum number of ice cream bars the boy can buy with coins coins. You must solve the problem by counting sort.",
      "examples": [
        "Input: costs = [1,3,2,4,1], coins = 7\nOutput: 4",
        "Input: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0",
        "Input: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6"
      ],
      "constraints": [
        "costs.length == n",
        "1 <= n <= 105",
        "1 <= costs[i] <= 105",
        "1 <= coins <= 108"
      ]
    },
    {
      "task_id": "h-index",
      "problem_description": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index. The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.",
      "examples": [
        "Input: citations = [3,0,6,1,5]\nOutput: 3",
        "Input: citations = [1,3,1]\nOutput: 1"
      ],
      "constraints": [
        "n == citations.length",
        "1 <= n <= 5000",
        "0 <= citations[i] <= 1000"
      ]
    },
    {
      "task_id": "minimum-number-of-moves-to-seat-everyone",
      "problem_description": "There are n available seats and n students standing in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student. You may perform the following move any number of times: Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1). Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat. Note that there may be multiple seats or students in the same position at the beginning.",
      "examples": [
        "Input: seats = [3,1,5], students = [2,7,4]\nOutput: 4",
        "Input: seats = [4,1,5,9], students = [1,3,2,6]\nOutput: 7",
        "Input: seats = [2,2,6,6], students = [1,3,2,6]\nOutput: 4"
      ],
      "constraints": [
        "n == seats.length == students.length",
        "1 <= n <= 100",
        "1 <= seats[i], students[j] <= 100"
      ]
    },
    {
      "task_id": "rectangle-area",
      "problem_description": "Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).",
      "examples": [
        "Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\nOutput: 45",
        "Input: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\nOutput: 16"
      ],
      "constraints": [
        "-104 <= ax1 <= ax2 <= 104",
        "-104 <= ay1 <= ay2 <= 104",
        "-104 <= bx1 <= bx2 <= 104",
        "-104 <= by1 <= by2 <= 104"
      ]
    },
    {
      "task_id": "projection-area-of-3d-shapes",
      "problem_description": "You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j). We view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the 'shadow' when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.",
      "examples": [
        "Input: grid = [[1,2],[3,4]]\nOutput: 17",
        "Input: grid = [[2]]\nOutput: 5",
        "Input: grid = [[1,0],[0,2]]\nOutput: 8"
      ],
      "constraints": [
        "n == grid.length == grid[i].length",
        "1 <= n <= 50",
        "0 <= grid[i][j] <= 50"
      ]
    },
    {
      "task_id": "check-if-it-is-a-straight-line",
      "problem_description": "You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.",
      "examples": [
        "Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\nOutput: true",
        "Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\nOutput: false"
      ],
      "constraints": [
        "2 <= coordinates.length <= 1000",
        "coordinates[i].length == 2",
        "-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4",
        "coordinates contains no duplicate point."
      ]
    },
    {
      "task_id": "k-closest-points-to-origin",
      "problem_description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2). The answer is guaranteed to be unique (except for the order that it is in).",
      "examples": [
        "Input: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]",
        "Input: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]"
      ],
      "constraints": [
        "1 <= k <= points.length <= 104",
        "-104 <= xi, yi <= 104"
      ]
    },
    {
      "task_id": "minimize-manhattan-distances",
      "problem_description": "You are given an array points representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi]. The distance between two points is defined as their Manhattan distance. Return the minimum possible value for maximum distance between any two points by removing exactly one point.",
      "examples": [
        "Input: points = [[3,10],[5,15],[10,2],[4,4]]\nOutput: 12",
        "Input: points = [[1,1],[1,1],[1,1]]\nOutput: 0"
      ],
      "constraints": [
        "3 <= points.length <= 105",
        "points[i].length == 2",
        "1 <= points[i][0], points[i][1] <= 108"
      ]
    },
    {
      "task_id": "concatenation-of-consecutive-binary-numbers",
      "problem_description": "Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 10^9 + 7.",
      "examples": [
        "Input: n = 1\nOutput: 1\nExplanation: \"1\" in binary corresponds to the decimal value 1.",
        "Input: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\". After concatenating them, we have \"11011\", which corresponds to the decimal value 27.",
        "Input: n = 12\nOutput: 505379714\nExplanation: The concatenation results in \"1101110010111011110001001101010111100\". The decimal value of that is 118505380540. After modulo 10^9 + 7, the result is 505379714."
      ],
      "constraints": [
        "1 <= n <= 10^5"
      ]
    },
    {
      "task_id": "count-number-of-homogenous-substrings",
      "problem_description": "Given a string s, return the number of homogenous substrings of s. A string is homogenous if all the characters of the string are the same. A substring is a contiguous sequence of characters within a string.",
      "examples": [
        "Input: s = \"abbcccaa\"\nOutput: 13",
        "Input: s = \"xy\"\nOutput: 2",
        "Input: s = \"zzzzz\"\nOutput: 15"
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s consists of lowercase letters."
      ]
    },
    {
      "task_id": "distribute-candies-among-children-ii",
      "problem_description": "You are given two positive integers n and limit. Return the total number of ways to distribute n candies among 3 children such that no child gets more than limit candies.",
      "examples": [
        "Input: n = 5, limit = 2\nOutput: 3\nExplanation: There are 3 ways to distribute 5 candies such that no child gets more than 2 candies: (1, 2, 2), (2, 1, 2) and (2, 2, 1).",
        "Input: n = 3, limit = 3\nOutput: 10\nExplanation: There are 10 ways to distribute 3 candies such that no child gets more than 3 candies: (0, 0, 3), (0, 1, 2), (0, 2, 1), (0, 3, 0), (1, 0, 2), (1, 1, 1), (1, 2, 0), (2, 0, 1), (2, 1, 0) and (3, 0, 0)."
      ],
      "constraints": [
        "1 <= n <= 106",
        "1 <= limit <= 106"
      ]
    },
    {
      "task_id": "total-hamming-distance",
      "problem_description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.",
      "examples": [
        "Input: nums = [4,14,2]\nOutput: 6",
        "Input: nums = [4,14,4]\nOutput: 4"
      ],
      "constraints": [
        "1 <= nums.length <= 104",
        "0 <= nums[i] <= 109",
        "The answer for the given input will fit in a 32-bit integer."
      ]
    },
    {
      "task_id": "maximum-number-of-visible-points",
      "problem_description": "You are given an array points, an integer angle, and your location, where location = [posx, posy] and points[i] = [xi, yi] both denote integral coordinates on the X-Y plane. Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, posx and posy cannot be changed. Your field of view in degrees is represented by angle, determining how wide you can see from any given view direction. Let d be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles [d - angle/2, d + angle/2]. You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view. There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points. Return the maximum number of points you can see.",
      "examples": [
        "Input: points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\nOutput: 3",
        "Input: points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\nOutput: 4",
        "Input: points = [[1,0],[2,1]], angle = 13, location = [1,1]\nOutput: 1"
      ],
      "constraints": [
        "1 <= points.length <= 105",
        "points[i].length == 2",
        "location.length == 2",
        "0 <= angle < 360",
        "0 <= posx, posy, xi, yi <= 100"
      ]
    },
    {
      "task_id": "maximum-length-of-semi-decreasing-subarrays",
      "problem_description": "You are given an integer array nums. Return the length of the longest semi-decreasing subarray of nums, and 0 if there are no such subarrays. A subarray is a contiguous non-empty sequence of elements within an array. A non-empty array is semi-decreasing if its first element is strictly greater than its last element.",
      "examples": [
        "Input: nums = [7,6,5,4,3,2,1,6,10,11]\nOutput: 8",
        "Input: nums = [57,55,50,60,61,58,63,59,64,60,63]\nOutput: 6",
        "Input: nums = [1,2,3,4]\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "-109 <= nums[i] <= 109"
      ]
    },
    {
      "task_id": "find-maximum-non-decreasing-array-length",
      "problem_description": "You are given a 0-indexed integer array nums. You can perform any number of operations, where each operation involves selecting a subarray of the array and replacing it with the sum of its elements. A subarray is a contiguous non-empty sequence of elements within an array. Return the maximum length of a non-decreasing array that can be made after applying operations.",
      "examples": [
        "Input: nums = [5,2,2]\nOutput: 1",
        "Input: nums = [1,2,3,4]\nOutput: 4",
        "Input: nums = [4,3,2,6]\nOutput: 3"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 105"
      ]
    },
    {
      "task_id": "car-fleet-ii",
      "problem_description": "There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents: positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1. speedi is the initial speed of the ith car in meters per second. For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet. Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car.",
      "examples": [
        "Input: cars = [[1,2],[2,1],[4,3],[7,2]]\nOutput: [1.00000,-1.00000,3.00000,-1.00000]",
        "Input: cars = [[3,4],[5,4],[6,3],[9,1]]\nOutput: [2.00000,1.00000,1.50000,-1.00000]"
      ],
      "constraints": [
        "1 <= cars.length <= 105",
        "1 <= positioni, speedi <= 106",
        "positioni < positioni+1"
      ]
    },
    {
      "task_id": "smallest-subsequence-of-distinct-characters",
      "problem_description": "Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.",
      "examples": [
        "Input: s = \"bcabc\"\nOutput: \"abc\"",
        "Input: s = \"cbacdcbc\"\nOutput: \"acdb\""
      ],
      "constraints": [
        "1 <= s.length <= 1000",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "number-of-people-that-can-be-seen-in-a-grid",
      "problem_description": "You are given an m x n 0-indexed 2D array of positive integers heights where heights[i][j] is the height of the person standing at position (i, j). A person standing at position (row1, col1) can see a person standing at position (row2, col2) if: The person at (row2, col2) is to the right or below the person at (row1, col1). More formally, this means that either row1 == row2 and col1 < col2 or row1 < row2 and col1 == col2. Everyone in between them is shorter than both of them. Return an m x n 2D array of integers answer where answer[i][j] is the number of people that the person at position (i, j) can see.",
      "examples": [
        "Input: heights = [[3,1,4,2,5]]\nOutput: [[2,1,2,1,0]]",
        "Input: heights = [[5,1],[3,1],[4,1]]\nOutput: [[3,1],[2,1],[1,0]]"
      ],
      "constraints": [
        "1 <= heights.length <= 400",
        "1 <= heights[i].length <= 400",
        "1 <= heights[i][j] <= 105"
      ]
    },
    {
      "task_id": "find-kth-largest-xor-coordinate-value",
      "problem_description": "You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k. The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed). Find the kth largest value (1-indexed) of all the coordinates of matrix.",
      "examples": [
        "Input: matrix = [[5,2],[1,6]], k = 1\nOutput: 7",
        "Input: matrix = [[5,2],[1,6]], k = 2\nOutput: 5",
        "Input: matrix = [[5,2],[1,6]], k = 3\nOutput: 4"
      ],
      "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 1000",
        "0 <= matrix[i][j] <= 106",
        "1 <= k <= m * n"
      ]
    },
    {
      "task_id": "query-kth-smallest-trimmed-number",
      "problem_description": "You are given a 0-indexed array of strings nums, where each string is of equal length and consists of only digits. You are also given a 0-indexed 2D integer array queries where queries[i] = [ki, trimi]. For each queries[i], you need to: Trim each number in nums to its rightmost trimi digits. Determine the index of the kith smallest trimmed number in nums. If two trimmed numbers are equal, the number with the lower index is considered to be smaller. Reset each number in nums to its original length. Return an array answer of the same length as queries, where answer[i] is the answer to the ith query. To trim to the rightmost x digits means to keep removing the leftmost digit, until only x digits remain. Strings in nums may contain leading zeros.",
      "examples": [
        "Input: nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\nOutput: [2,2,1,0]",
        "Input: nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\nOutput: [3,0]"
      ],
      "constraints": [
        "1 <= nums.length <= 100",
        "1 <= nums[i].length <= 100",
        "nums[i] consists of only digits.",
        "All nums[i].length are equal.",
        "1 <= queries.length <= 100",
        "queries[i].length == 2",
        "1 <= ki <= nums.length",
        "1 <= trimi <= nums[i].length"
      ]
    },
    {
      "task_id": "wiggle-sort-ii",
      "problem_description": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... You may assume the input array always has a valid answer.",
      "examples": [
        "Input: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.",
        "Input: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]"
      ],
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "0 <= nums[i] <= 5000",
        "It is guaranteed that there will be an answer for the given input nums."
      ]
    },
    {
      "task_id": "kth-largest-element-in-an-array",
      "problem_description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.",
      "examples": [
        "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
        "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
      ],
      "constraints": [
        "1 <= k <= nums.length <= 105",
        "-104 <= nums[i] <= 104"
      ]
    },
    {
      "task_id": "k-closest-points-to-origin",
      "problem_description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2). The answer is guaranteed to be unique (except for the order that it is in).",
      "examples": [
        "Input: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]",
        "Input: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]"
      ],
      "constraints": [
        "1 <= k <= points.length <= 104",
        "-104 <= xi, yi <= 104"
      ]
    },
    {
      "task_id": "longest-happy-prefix",
      "problem_description": "A string is called a happy prefix if it is a non-empty prefix which is also a suffix (excluding itself). Given a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
      "examples": [
        "Input: s = \"level\"\nOutput: \"l\"",
        "Input: s = \"ababab\"\nOutput: \"abab\""
      ],
      "constraints": [
        "1 <= s.length <= 105",
        "s contains only lowercase English letters."
      ]
    },
    {
      "task_id": "k-divisible-elements-subarrays",
      "problem_description": "Given an integer array nums and two integers k and p, return the number of distinct subarrays, which have at most k elements that are divisible by p. A subarray is defined as a non-empty contiguous sequence of elements in an array.",
      "examples": [
        "Input: nums = [2,3,3,2,2], k = 2, p = 2\nOutput: 11",
        "Input: nums = [1,2,3,4], k = 4, p = 1\nOutput: 10"
      ],
      "constraints": [
        "1 <= nums.length <= 200",
        "1 <= nums[i], p <= 200",
        "1 <= k <= nums.length"
      ]
    },
    {
      "task_id": "shortest-palindrome",
      "problem_description": "You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation.",
      "examples": [
        "Input: s = \"aacecaaa\"\nOutput: \"aaacecaaa\"",
        "Input: s = \"abcd\"\nOutput: \"dcbabcd\""
      ],
      "constraints": [
        "0 <= s.length <= 5 * 104",
        "s consists of lowercase English letters only."
      ]
    },
    {
      "task_id": "check-if-a-string-contains-all-binary-codes-of-size-k",
      "problem_description": "Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.",
      "examples": [
        "Input: s = \"00110110\", k = 2\nOutput: true",
        "Input: s = \"0110\", k = 1\nOutput: true",
        "Input: s = \"0110\", k = 2\nOutput: false"
      ],
      "constraints": [
        "1 <= s.length <= 5 * 10^5",
        "s[i] is either '0' or '1'.",
        "1 <= k <= 20"
      ]
    },
    {
      "task_id": "longest-repeating-substring",
      "problem_description": "Given a string s, return the length of the longest repeating substrings. If no repeating substring exists, return 0.",
      "examples": [
        "Input: s = \"abcd\"\nOutput: 0\nExplanation: There is no repeating substring.",
        "Input: s = \"abbaba\"\nOutput: 2\nExplanation: The longest repeating substrings are \"ab\" and \"ba\", each of which occurs twice.",
        "Input: s = \"aabcaabdaab\"\nOutput: 3\nExplanation: The longest repeating substring is \"aab\", which occurs 3 times."
      ],
      "constraints": [
        "1 <= s.length <= 2000",
        "s consists of lowercase English letters."
      ]
    },
    {
      "task_id": "maximum-profitable-triplets-with-increasing-prices-ii",
      "problem_description": "Given the 0-indexed arrays prices and profits of length n. There are n items in a store where the ith item has a price of prices[i] and a profit of profits[i]. We have to pick three items with the following condition: prices[i] < prices[j] < prices[k] where i < j < k. If we pick items with indices i, j and k satisfying the above condition, the profit would be profits[i] + profits[j] + profits[k]. Return the maximum profit we can get, and -1 if it's not possible to pick three items with the given condition.",
      "examples": [
        "Input: prices = [10,2,3,4], profits = [100,2,7,10]\nOutput: 19",
        "Input: prices = [1,2,3,4,5], profits = [1,5,3,4,6]\nOutput: 15",
        "Input: prices = [4,3,2,1], profits = [33,20,19,87]\nOutput: -1"
      ],
      "constraints": [
        "3 <= prices.length == profits.length <= 50000",
        "1 <= prices[i] <= 5000",
        "1 <= profits[i] <= 106"
      ]
    },
    {
      "task_id": "find-a-value-of-a-mysterious-function-closest-to-target",
      "problem_description": "Winston has an integer array arr and an integer target and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible. Notice that func should be called with the values l and r where 0 <= l, r < arr.length.",
      "examples": [
        "Input: arr = [9,12,3,7,15], target = 5\nOutput: 2",
        "Input: arr = [1000000,1000000,1000000], target = 1\nOutput: 999999",
        "Input: arr = [1,2,4,8,16], target = 0\nOutput: 0"
      ],
      "constraints": [
        "1 <= arr.length <= 105",
        "1 <= arr[i] <= 106",
        "0 <= target <= 107"
      ]
    },
    {
      "task_id": "rectangle-area-ii",
      "problem_description": "You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner. Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once. Return the total area. Since the answer may be too large, return it modulo 10^9 + 7.",
      "examples": [
        "Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\nOutput: 6",
        "Input: rectangles = [[0,0,1000000000,1000000000]]\nOutput: 49"
      ],
      "constraints": [
        "1 <= rectangles.length <= 200",
        "rectangles[i].length == 4",
        "0 <= xi1, yi1, xi2, yi2 <= 10^9",
        "xi1 <= xi2",
        "yi1 <= yi2",
        "All rectangles have non zero area."
      ]
    },
    {
      "task_id": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
      "problem_description": "You are given a string num representing the digits of a very large integer and an integer k. You are allowed to swap any two adjacent digits of the integer at most k times. Return the minimum integer you can obtain also as a string.",
      "examples": [
        "Input: num = \"4321\", k = 4\nOutput: \"1342\"",
        "Input: num = \"100\", k = 1\nOutput: \"010\"",
        "Input: num = \"36789\", k = 1000\nOutput: \"36789\""
      ],
      "constraints": [
        "1 <= num.length <= 3 * 104",
        "num consists of only digits and does not contain leading zeros.",
        "1 <= k <= 109"
      ]
    },
    {
      "task_id": "count-good-triplets-in-an-array",
      "problem_description": "You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1]. A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z. Return the total number of good triplets.",
      "examples": [
        "Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]\nOutput: 1",
        "Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\nOutput: 4"
      ],
      "constraints": [
        "n == nums1.length == nums2.length",
        "3 <= n <= 105",
        "0 <= nums1[i], nums2[i] <= n - 1",
        "nums1 and nums2 are permutations of [0, 1, ..., n - 1]"
      ]
    },
    {
      "task_id": "number-of-ways-to-reorder-array-to-get-same-bst",
      "problem_description": "Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.",
      "examples": [
        "Input: nums = [2,1,3]\nOutput: 1",
        "Input: nums = [3,4,5,1,2]\nOutput: 5",
        "Input: nums = [1,2,3]\nOutput: 0"
      ],
      "constraints": [
        "1 <= nums.length <= 1000",
        "1 <= nums[i] <= nums.length",
        "All integers in nums are distinct."
      ]
    },
    {
      "task_id": "find-all-people-with-secret",
      "problem_description": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson. Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa. The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.",
      "examples": [
        "Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\nOutput: [0,1,2,3,5]",
        "Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\nOutput: [0,1,3]",
        "Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\nOutput: [0,1,2,3,4]"
      ],
      "constraints": [
        "2 <= n <= 105",
        "1 <= meetings.length <= 105",
        "meetings[i].length == 3",
        "0 <= xi, yi <= n - 1",
        "xi != yi",
        "1 <= timei <= 105",
        "1 <= firstPerson <= n - 1"
      ]
    },
    {
      "task_id": "synonymous-sentences",
      "problem_description": "You are given a list of equivalent string pairs synonyms where synonyms[i] = [si, ti] indicates that si and ti are equivalent strings. You are also given a sentence text. Return all possible synonymous sentences sorted lexicographically.",
      "examples": [
        "Input: synonyms = [[\"happy\",\"joy\"],[\"sad\",\"sorrow\"],[\"joy\",\"cheerful\"]], text = \"I am happy today but was sad yesterday\" Output: [\"I am cheerful today but was sad yesterday\",\"I am cheerful today but was sorrow yesterday\",\"I am happy today but was sad yesterday\",\"I am happy today but was sorrow yesterday\",\"I am joy today but was sad yesterday\",\"I am joy today but was sorrow yesterday\"]",
        "Input: synonyms = [[\"happy\",\"joy\"],[\"cheerful\",\"glad\"]], text = \"I am happy today but was sad yesterday\" Output: [\"I am happy today but was sad yesterday\",\"I am joy today but was sad yesterday\"]"
      ],
      "constraints": [
        "0 <= synonyms.length <= 10",
        "synonyms[i].length == 2",
        "1 <= si.length, ti.length <= 10",
        "si != ti",
        "text consists of at most 10 words.",
        "All the pairs of synonyms are unique.",
        "The words of text are separated by single spaces."
      ]
    },
    {
      "task_id": "sentence-similarity-ii",
      "problem_description": "We can represent a sentence as an array of words. Given two sentences sentence1 and sentence2 each represented as a string array and given an array of string pairs similarPairs where similarPairs[i] = [xi, yi] indicates that the two words xi and yi are similar. Return true if sentence1 and sentence2 are similar, or false if they are not similar. Two sentences are similar if they have the same length and sentence1[i] and sentence2[i] are similar. A word is always similar to itself, and the similarity relation is transitive.",
      "examples": [
        "Input: sentence1 = [\"great\",\"acting\",\"skills\"], sentence2 = [\"fine\",\"drama\",\"talent\"], similarPairs = [[\"great\",\"good\"],[\"fine\",\"good\"],[\"drama\",\"acting\"],[\"skills\",\"talent\"]]\nOutput: true",
        "Input: sentence1 = [\"I\",\"love\",\"leetcode\"], sentence2 = [\"I\",\"love\",\"onepiece\"], similarPairs = [[\"manga\",\"onepiece\"],[\"platform\",\"anime\"],[\"leetcode\",\"platform\"],[\"anime\",\"manga\"]]\nOutput: true",
        "Input: sentence1 = [\"I\",\"love\",\"leetcode\"], sentence2 = [\"I\",\"love\",\"onepiece\"], similarPairs = [[\"manga\",\"hunterXhunter\"],[\"platform\",\"anime\"],[\"leetcode\",\"platform\"],[\"anime\",\"manga\"]]\nOutput: false"
      ],
      "constraints": [
        "1 <= sentence1.length, sentence2.length <= 1000",
        "1 <= sentence1[i].length, sentence2[i].length <= 20",
        "sentence1[i] and sentence2[i] consist of lower-case and upper-case English letters.",
        "0 <= similarPairs.length <= 2000",
        "similarPairs[i].length == 2",
        "1 <= xi.length, yi.length <= 20",
        "xi and yi consist of English letters."
      ]
    },
    {
      "task_id": "satisfiability-of-equality-equations",
      "problem_description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\". Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names. Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
      "examples": [
        "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations.",
        "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
      ],
      "constraints": [
        "1 <= equations.length <= 500",
        "equations[i].length == 4",
        "equations[i][0] is a lowercase letter.",
        "equations[i][1] is either '=' or '!'.",
        "equations[i][2] is '='.",
        "equations[i][3] is a lowercase letter."
      ]
    },
    {
      "task_id": "root-equals-sum-of-children",
      "problem_description": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child. Return true if the value of the root is equal to the sum of the values of its two children, or false otherwise.",
      "examples": [
        "Input: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.",
        "Input: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false."
      ],
      "constraints": [
        "The tree consists only of the root, its left child, and its right child.",
        "-100 <= Node.val <= 100"
      ]
    },
    {
      "task_id": "maximum-binary-tree-ii",
      "problem_description": "A maximum tree is a tree where every node has a value greater than any other value in its subtree. You are given the root of a maximum binary tree and an integer val. The given tree was constructed from a list a (root = Construct(a)) recursively with the following Construct(a) routine: If a is empty, return null. Otherwise, let a[i] be the largest element of a. Create a root node with the value a[i]. The left child of root will be Construct([a[0], a[1], ..., a[i - 1]]). The right child of root will be Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]). Return root. Suppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values. Return Construct(b).",
      "examples": [
        "Input: root = [4,1,3,null,null,2], val = 5\nOutput: [5,4,null,1,3,null,null,2]",
        "Input: root = [5,2,4,null,1], val = 3\nOutput: [5,2,4,null,1,null,3]",
        "Input: root = [5,2,3,null,1], val = 4\nOutput: [5,2,4,null,1,3]"
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 100].",
        "1 <= Node.val <= 100",
        "All the values of the tree are unique.",
        "1 <= val <= 100"
      ]
    },
    {
      "task_id": "sum-of-left-leaves",
      "problem_description": "Given the root of a binary tree, return the sum of all left leaves. A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.",
      "examples": [
        "Input: root = [3,9,20,null,null,15,7]\nOutput: 24",
        "Input: root = [1]\nOutput: 0"
      ],
      "constraints": [
        "The number of nodes in the tree is in the range [1, 1000].",
        "-1000 <= Node.val <= 1000"
      ]
    },
    {
      "task_id": "all-elements-in-two-binary-search-trees",
      "problem_description": "Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.",
      "examples": [
        "Input: root1 = [2,1,4], root2 = [1,0,3]\nOutput: [0,1,1,2,3,4]",
        "Input: root1 = [1,null,8], root2 = [8,1]\nOutput: [1,1,8,8]"
      ],
      "constraints": [
        "The number of nodes in each tree is in the range [0, 5000].",
        "-105 <= Node.val <= 105"
      ]
    },
    {
      "task_id": "count-nodes-with-the-highest-score",
      "problem_description": "There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1. Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees. Return the number of nodes that have the highest score.",
      "examples": [
        "Input: parents = [-1,2,0,2,0]\nOutput: 3\nExplanation:\n- The score of node 0 is: 3 * 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 * 1 * 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.",
        "Input: parents = [-1,2,0]\nOutput: 2\nExplanation:\n- The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 * 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score."
      ],
      "constraints": [
        "n == parents.length",
        "2 <= n <= 105",
        "parents[0] == -1",
        "0 <= parents[i] <= n - 1 for i != 0",
        "parents represents a valid binary tree."
      ]
    },
    {
      "task_id": "minimize-deviation-in-array",
      "problem_description": "You are given an array nums of n positive integers. You can perform two types of operations on any element of the array any number of times: If the element is even, divide it by 2. If the element is odd, multiply it by 2. The deviation of the array is the maximum difference between any two elements in the array. Return the minimum deviation the array can have after performing some number of operations.",
      "examples": [
        "Input: nums = [1,2,3,4]\nOutput: 1",
        "Input: nums = [4,1,5,20,3]\nOutput: 3",
        "Input: nums = [2,10,8]\nOutput: 3"
      ],
      "constraints": [
        "n == nums.length",
        "2 <= n <= 5 * 104",
        "1 <= nums[i] <= 10^9"
      ]
    },
    {
      "task_id": "find-servers-that-handled-most-number-of-requests",
      "problem_description": "You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm: The ith (0-indexed) request arrives. If all servers are busy, the request is dropped (not handled at all). If the (i % k)th server is available, assign the request to that server. Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). You are given a strictly increasing array arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another array load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers. Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.",
      "examples": [
        "Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] Output: [1]",
        "Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2] Output: [0]",
        "Input: k = 3, arrival = [1,2,3], load = [10,12,11] Output: [0,1,2]"
      ],
      "constraints": [
        "1 <= k <= 105",
        "1 <= arrival.length, load.length <= 105",
        "arrival.length == load.length",
        "1 <= arrival[i], load[i] <= 109",
        "arrival is strictly increasing."
      ]
    },
    {
      "task_id": "pizza-with-3n-slices",
      "problem_description": "There is a pizza with 3n slices of varying size. You and your friends will take slices of pizza as follows: You will pick any pizza slice. Your friend Alice will pick the next slice in the anti-clockwise direction of your pick. Your friend Bob will pick the next slice in the clockwise direction of your pick. Repeat until there are no more slices of pizzas. Given an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick.",
      "examples": [
        "Input: slices = [1,2,3,4,5,6]\nOutput: 10\nExplanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.",
        "Input: slices = [8,9,8,6,1,1]\nOutput: 16\nExplanation: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8."
      ],
      "constraints": [
        "3 * n == slices.length",
        "1 <= slices.length <= 500",
        "1 <= slices[i] <= 1000"
      ]
    },
    {
      "task_id": "group-the-people-given-the-group-size-they-belong-to",
      "problem_description": "There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1. You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. Return a list of groups such that each person i is in a group of size groupSizes[i]. Each person should appear in exactly one group, and every person must be in a group. It is guaranteed that there will be at least one valid solution for the given input.",
      "examples": [
        "Input: groupSizes = [3,3,3,3,3,1,3]\nOutput: [[5],[0,1,2],[3,4,6]]",
        "Input: groupSizes = [2,1,3,3,3,2]\nOutput: [[1],[0,5],[2,3,4]]"
      ],
      "constraints": [
        "groupSizes.length == n",
        "1 <= n <= 500",
        "1 <= groupSizes[i] <= n"
      ]
    },
    {
      "task_id": "minimize-or-of-remaining-elements-using-operations",
      "problem_description": "You are given a 0-indexed integer array nums and an integer k. In one operation, you can pick any index i of nums such that 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND operator. Return the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.",
      "examples": [
        "Input: nums = [3,5,3,2,7], k = 2\nOutput: 3",
        "Input: nums = [7,3,15,14,2,8], k = 4\nOutput: 2",
        "Input: nums = [10,7,10,3,9,14,9,4], k = 1\nOutput: 15"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "0 <= nums[i] < 230",
        "0 <= k < nums.length"
      ]
    },
    {
      "task_id": "min-cost-to-connect-all-points",
      "problem_description": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
      "examples": [
        "Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20",
        "Input: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18"
      ],
      "constraints": [
        "1 <= points.length <= 1000",
        "-106 <= xi, yi <= 106",
        "All pairs (xi, yi) are distinct."
      ]
    },
    {
      "task_id": "optimize-water-distribution-in-a-village",
      "problem_description": "There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes. For each house i, we can either build a well inside it directly with cost wells[i - 1], or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes where each pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j and house2j together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs. Return the minimum total cost to supply water to all houses.",
      "examples": [
        "Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]\nOutput: 3",
        "Input: n = 2, wells = [1,1], pipes = [[1,2,1],[1,2,2]]\nOutput: 2"
      ],
      "constraints": [
        "2 <= n <= 104",
        "wells.length == n",
        "0 <= wells[i] <= 105",
        "1 <= pipes.length <= 104",
        "pipes[j].length == 3",
        "1 <= house1j, house2j <= n",
        "0 <= costj <= 105",
        "house1j != house2j"
      ]
    },
    {
      "task_id": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
      "problem_description": "Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight. Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order.",
      "examples": [
        "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] Output: [[0,1],[2,3,4,5]]",
        "Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] Output: [[],[0,1,2,3]]"
      ],
      "constraints": [
        "2 <= n <= 100",
        "1 <= edges.length <= min(200, n * (n - 1) / 2)",
        "edges[i].length == 3",
        "0 <= ai < bi < n",
        "1 <= weighti <= 1000",
        "All pairs (ai, bi) are distinct."
      ]
    },
    {
      "task_id": "connecting-cities-with-minimum-cost",
      "problem_description": "There are n cities labeled from 1 to n. You are given the integer n and an array connections where connections[i] = [xi, yi, costi] indicates that the cost of connecting city xi and city yi (bidirectional connection) is costi. Return the minimum cost to connect all the n cities such that there is at least one path between each pair of cities. If it is impossible to connect all the n cities, return -1. The cost is the sum of the connections' costs used.",
      "examples": [
        "Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]] Output: 6",
        "Input: n = 4, connections = [[1,2,3],[3,4,4]] Output: -1"
      ],
      "constraints": [
        "1 <= n <= 104",
        "1 <= connections.length <= 104",
        "connections[i].length == 3",
        "1 <= xi, yi <= n",
        "xi != yi",
        "0 <= costi <= 105"
      ]
    },
    {
      "task_id": "minimum-window-subsequence",
      "problem_description": "Given strings s1 and s2, return the minimum contiguous substring part of s1, so that s2 is a subsequence of the part. If there is no such window in s1 that covers all characters in s2, return the empty string \"\". If there are multiple such minimum-length windows, return the one with the left-most starting index.",
      "examples": [
        "Input: s1 = \"abcdebdde\", s2 = \"bde\"\nOutput: \"bcde\"",
        "Input: s1 = \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\", s2 = \"u\"\nOutput: \"\""
      ],
      "constraints": [
        "1 <= s1.length <= 2 * 104",
        "1 <= s2.length <= 100",
        "s1 and s2 consist of lowercase English letters."
      ]
    },
    {
      "task_id": "count-subarrays-with-score-less-than-k",
      "problem_description": "The score of an array is defined as the product of its sum and its length. Given a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k. A subarray is a contiguous sequence of elements within an array.",
      "examples": [
        "Input: nums = [2,1,4,3,5], k = 10\nOutput: 6",
        "Input: nums = [1,1,1], k = 5\nOutput: 5"
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 105",
        "1 <= k <= 1015"
      ]
    },
    {
      "task_id": "maximum-strong-pair-xor-ii",
      "problem_description": "You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition: |x - y| <= min(x, y). You need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array. Return the maximum XOR value out of all possible strong pairs in the array nums. Note that you can pick the same integer twice to form a pair.",
      "examples": [
        "Input: nums = [1,2,3,4,5]\nOutput: 7",
        "Input: nums = [10,100]\nOutput: 0",
        "Input: nums = [500,520,2500,3000]\nOutput: 1020"
      ],
      "constraints": [
        "1 <= nums.length <= 5 * 104",
        "1 <= nums[i] <= 220 - 1"
      ]
    },
    {
      "task_id": "shortest-subarray-with-or-at-least-k-ii",
      "problem_description": "You are given an array nums of non-negative integers and an integer k. An array is called special if the bitwise OR of all of its elements is at least k. Return the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.",
      "examples": [
        "Input: nums = [1,2,3], k = 2\nOutput: 1",
        "Input: nums = [2,1,8], k = 10\nOutput: 3",
        "Input: nums = [1,2], k = 0\nOutput: 1"
      ],
      "constraints": [
        "1 <= nums.length <= 2 * 105",
        "0 <= nums[i] <= 109",
        "0 <= k <= 109"
      ]
    },
    {
      "task_id": "minimum-number-of-operations-to-make-array-continuous",
      "problem_description": "You are given an integer array nums. In one operation, you can replace any element in nums with any integer. nums is considered continuous if both of the following conditions are fulfilled: All elements in nums are unique. The difference between the maximum element and the minimum element in nums equals nums.length - 1. Return the minimum number of operations to make nums continuous.",
      "examples": [
        "Input: nums = [4,2,5,3]\nOutput: 0\nExplanation: nums is already continuous.",
        "Input: nums = [1,2,3,5,6]\nOutput: 1\nExplanation: One possible solution is to change the last element to 4. The resulting array is [1,2,3,5,4], which is continuous.",
        "Input: nums = [1,10,100,1000]\nOutput: 3\nExplanation: One possible solution is to:\n- Change the second element to 2.\n- Change the third element to 3.\n- Change the fourth element to 4.\nThe resulting array is [1,2,3,4], which is continuous."
      ],
      "constraints": [
        "1 <= nums.length <= 105",
        "1 <= nums[i] <= 109"
      ]
    }
  ]
}